[["index.html", "Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Vorwort", " Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Anne Sophie Küllmer sophie.kuellmer@uni-leipzig.de Peter Kannewitz peter.kannewitz@uni-leipzig.de Peer Keßler Stand: 2022-11-05 Vorwort Dieses Handout ist Teil des Grundkurses in R am URZ und am Academic Lab der Uni Leipzig. Besonderem Dank gilt Stephan Poppe und dem Statistik-Team des Instituts für Soziologie für die Unterstützung beim Erstellen der Materialien für diesen Kurs. Hinweis: Dieses Handout ist ständig in Bearbeitung und erhebt keinen Anspruch auf Vollständigkeit. Bitte informiert uns, sollten Angaben nicht mehr aktuell sein bzw. sollten sich Fehler eingeschlichen haben. Vielen Dank! "],["hinweise-zur-verwendung-des-handouts.html", "Hinweise zur Verwendung des Handouts", " Hinweise zur Verwendung des Handouts In den einzelnen Kapiteln wird immer wieder R Code ausgeführt. Dabei wird immer im ersten Block der jeweilige Ausdruck angegeben und im zweiten das dazugehörige Ergebnis, was wie folgt aussieht: 1+1 ## [1] 2 Am Ende eines jeden Kapitels gibt es eine kleine Checkliste, welche als “Prüfe dich selbst” überschrieben ist. Anhand dieser könnt ihr euch testen, ob ihr allem folgen konntet und die Sachverhalte verinnerlicht habt. Wenn nicht, habt ihr dann vielleicht einen Anhaltspunkt, was ihr später vielleicht noch einmal nachlesen könntet. Es empfiehlt sich über die Menüleiste oben die Anzeigeeinstellungen (A) zu ändern. Wenn ihr Mal ein Kapitel durcharbeiten wollt, ist eine Schriftart mit Serifen und ein etwas dunkler Hintergrund vielleicht angenehmer. Also probiert das gerne mal aus! Das gesamte Handout ist über GitHub Pages veröffentlicht. Wenn ihr einen Fehler entdeckt oder Anmerkungen habt, dann zögert nicht ein Issue auf zu machen und Änderungen vorzuschlagen! Über das Auge oben in der Menüleiste kommt ihr zum Repository. "],["einführung.html", "Kapitel 1 Einführung 1.1 Was ist R und warum sollte man R lernen? 1.2 Installation", " Kapitel 1 Einführung Abb. 1.1: R Logo (https://www.r-project.org/logo/) 1.1 Was ist R und warum sollte man R lernen? R ist eine freie Programmiersprache, die in erster Linie für statistische Analysen konzipiert wurde. Durch ihre große Community (siehe Stack Overflow oder RBlogger) und ihre ständige Weiterentwicklung durch sogenannte Packages, ist der Funktionsumfang von R praktisch unbegrenzt. Neben den klassischen Funktionen statistischer Software (Datenaufbereitung, Analysen, Graphikerstellung) sind z.B. folgende Anwendungen möglich: Erstellen von Präsentationen und Papern (mit RMarkdown) Webscraping Qualitative Textanalyse Auslesen von Datenbanken Automatisierungen uvm. Zum Teil durch die vielfältigen Anwendungsmöglichkeiten hat sich bzw. entwickelt sich R zum Goldstandard in der akademischen Welt und in vielen Bereichen der Wirtschaft1. Wie auch bei Sprachen, lernt man Programmiersprachen nicht (nur) durch Kurse. Eine aktive Auseinandersetzung mit konkreten Problemen hilft, “fließender” im Umgang mit der Sprache zu werden. Kommt man einmal nicht weiter (wird passieren… versprochen!), hilft es, sich so lange mit dem Thema zu beschäftigen, bis eine Lösung gefunden wurde. Warum sollte man das auf sich nehmen? 6 Gründe, R zu lernen: Open Source und plattformübergreifend Praktisch unbegrenzter Funktionsumfang Entwickelt sich zum Standard in akademischer Welt und Wirtschaft Publizierfähige Graphiken Integration von Aufbereitung, Analyse und Präsentation Internationale Community (Stack Overflow, RBloggers etc.) 1.2 Installation Zunächst muss unser Computer R “lernen”. Um R zu installieren, gehe auf die entsprechende Cran Website. Wähle dein Betriebssystem aus und folge den Anweisungen auf der Website. Um produktiv zu arbeiten, sollte zusätzlich die Open Source-Version von RStudio installiert werden. Weitere Infos hierzu gibt es hier. https://analyticsindiamag.com/has-python-completely-edged-out-r-in-data-science-field/↩︎ "],["oberfläche.html", "Kapitel 2 Oberfläche 2.1 R GUI 2.2 RStudio 2.3 Prüfe dich selbst", " Kapitel 2 Oberfläche 2.1 R GUI Mit der Installation von R wird gleichzeitig ein Graphical User Interface (GUI) mitinstalliert. Hier können wir bereits R Code eingeben und mit Enter an den Computer übergeben. In der nächsten Zeile wird die Antwort vom Computer an uns zurückgegeben. Abb. 2.1: R GUI Diese Oberfläche ist jedoch wenig “komfortabel”. Sie bietet keine zusätzlichen Editoren oder Fenster, um z.B. die gespeicherten Objekte oder Graphiken anzuzeigen. 2.2 RStudio Abb. 2.2: RStudio Logo (https://www.rstudio.com/about/logos/) Abb. 2.3: RStudio Interface RStudio bietet eine nutzer*innenfreundliche (und freie) Alternative für die Nutzung von R. Hier sind zusätzliche Editoren und Übersichten enthalten. Zu nennen ist beispielsweise: Script-Editor Übersicht über Objekte in globaler Umgebung Übersicht über Packages Einfache Dateienhandhabung durch Projects u.v.m. Das Interface von RStudio besteht aus mehreren Fenstern. 2.2.1 Console Abb. 2.4: Console Die R Console dient zur direkten Übergabe von Ausdrücken bzw. Funktionen an R und ist identisch mit der Anzeige in der R GUI. Diese eignet sich für kleine Tasks bzw. Tests. Das Ergebnis wird direkt unterhalb des Befehls angezeigt. Außerderm werden Ergebnisse aus den Scripten, die keine Graphiken sind, hier angezeigt. Nachdem Code hier eingetippt wurde, wird die Befehlszeile mit der Taste ENTER ausgeführt. 2.2.2 Script Editor Abb. 2.5: Script Editor In der Console kann euer Code langfristig nicht gespeichert werden. Sogenannte R Scripte ermöglichen euch, euren Code zu speichern und nacheinander auszuführen. Der entsprechende Editor muss zunächst händisch geöffnet werden: File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script Nachdem Code geschrieben wurde, kann der Code mit folgender Tastenkombination ausgeführt werden: strg + ENTER (Win) bzw. command + ENTER (Mac) Hierzu genügt es, wenn sich der Cursor in einer der Zeilen der Befehlssequenz befindet. Sollen mehrere Befehlssequenzen ausgeführt werden, müssen diese vorher markiert werden. Mit # lassen sich Kommentare in das Script schreiben. Zeilen, in denen dieses Zeichen steht, werden von R ignoriert und nicht ausgeführt. 2.2.3 File-Editor und Environment Abb. 2.6: File-Editor und Environment-Oberfläche Zusätzlich zu der Console und dem Skript-Editor bietet RStudio weitere Fenster, die die Arbeit mit R vereinfachen sollen. Das Fenster unten rechts (Standardeinstellung, Abbildung 2.6a) beinhaltet einen File-Editor (ähnlich zum File Browser (Win) bzw. Finder (Mac)). Hier können Dateien und Verzeichnisstrukturen angesehen und bearbeitet werden (neuer Ordner, Umbenennen von Dateien). Außerdem werden hier Graphiken angezeigt, wenn diese über Code in Scripten oder in der Console erzeugt werden. Des Weiteren gibt es hier eine Übersicht über Packages und das Help Fenster. Oben rechts (Standardeinstellung, Abbildung 2.6b) existiert die Global Environment, in dem alle gespeicherten Objekte angezeigt werden. Schließlich kann hier auf die History und Verbindungen, wie GitHub, zugegriffen werden. 2.3 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest die wesentliche Funktionsweise von R verstanden haben. Du solltest den Aufbau von RStudio kennen. Du solltest wissen, was ein Script ist und wie es geöffnet werden kann. Du solltest wissen, wie Befehlssequenzen in der Console und in einem Script ausgeführt werden. "],["atomare-datentypen.html", "Kapitel 3 Atomare Datentypen 3.1 Arithmetische Grundoperationen und Basisfunktionen 3.2 Erzeugung von referenzierbaren Objekten 3.3 Logische Werte und Operationen 3.4 Zeichenketten (character strings) 3.5 Klasse eines Datenobjektes 3.6 Spezielle Werte 3.7 Prüfe dich selbst 3.8 Literaturverweise", " Kapitel 3 Atomare Datentypen Datentypen sind die Grundlage einer jeden Programmiersprache und somit essenziell zum Verständnis dieser. Sie dienen dazu, verschiedene Typen zu unterscheiden, wie etwa Zahlen von Buchstaben. Das ist besonders wichtig, da wir mit unterschiedlichen ‘Typen’ unterschiedliche Operationen ausführen bzw. nicht ausführen können. Zum Beispiel können wir mit Zahlen rechnen, mit Buchstaben hingegen nicht. Mit logischen Bedingungen können wir wiederum Wahrheitswerte ermitteln, mit Zahlen hingegen nicht. Zu wissen, welche Eigenschaften die verschiedenen Datentypen haben und welche Operationen mit diesen möglich sind, hilft dabei, vielen potenziellen Fehlern vorzubeugen und so Frustration zu vermeiden. Zunächst einmal wollen wir uns die atomaren Datentypen anschauen. Diese bilden die Grundlage aller folgenden Datenstrukturen. Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric rationale Zahlen 5.2456 logical logische Werte TRUE character Zeichenfolge “Mexico” NA,NULL,NaN unbestimmt, leer, undefiniert Inf unendlich Die numerischen Datentypen integer und numeric erlauben es, numerische Informationen zu repräsentieren. Mit dem Datentyp logical können logische Informationen repräsentiert werden. Um symbolische Informationen zu repräsentieren, verwenden wir den Datentyp character. Mit numerischen, logischen und symbolischen Informationen ist es bereits möglich, eine Vielzahl von Sachverhalten auszudrücken. Was dies sein kann, wollen wir uns im Folgenden anschauen. 3.1 Arithmetische Grundoperationen und Basisfunktionen R beherrscht für alle Zahlen die arithmetischen Grundoperationen und eignet sich somit wunderbar als Taschenrechner. Operation Beschreibung Beispiel +,- Addition, Subtraktion 3-1.2 *,/ Multiplikation, Division 4.8/4 ^ Potenz 5^2 Beispiel: 1+2 ## [1] 3 2*3.5 ## [1] 7 10.1^3 ## [1] 1030.301 R verfügt für Daten numerischen Typs über viele elementare Grundfunktionen. Hier nur ein paar wenige relevante Beispiele: Operation Beschreibung Beispiel sqrt() Quadratwurzel sqrt(9) abs() Absolutbetrag abs(-12) log(),exp() Logarithmus und Expontentialfunktion exp(3) round() Runden round(2.12) sqrt(5) ## [1] 2.236068 log(3) ## [1] 1.098612 3.1.1 Funktionsaufrufe Funktionen sind ein wichtiger Teil von R und werden syntaktisch durch eine öffnende und eine schließende Klammer gekennzeichnet, nach diesem Schema: funktion(). Gerade haben wir bereits eine Funktion ausgeführt, indem wir sqrt(9) aufgerufen haben. Ausführlich werden Funktionen noch in Kapitel 5 besprochen. Ein paar Grundlagen wollen wir hier aber schon einmal einführen: Funktionsaufrufe erfolgen in der Regel über das Schema Funktionsname(Argument 1, Argument 2, ...) Beispiel: Die Funktion signif(x,digits) rundet eine Zahl x auf digits signifikante Stellen. Argumente haben zumeist einen festen Namen, sodass diesen eindeutig Werte zugewiesen werden können: signif(x = 12.3456, digits = 3) ## [1] 12.3 Alternativ können aufgrund der Position bzw. der Ordnung den Argumenten Werte zugewiesen werden: signif(12.3456, 3) ## [1] 12.3 3.1.2 Objekte, Funktionen und Referenzen “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” (John M. Chambers) 2 Funktionen haben wir gerade kennengelernt, also kennen wir auch schon “Everything that happens”. Objekte haben wir auch schon durchgehend verwendet. Geben wir etwa 3 oder \"password\" in die Konsole ein, wird ein entsprechendes Objekt im Speicher erzeugt. Auf diese Objekte haben wir allerdings anschließend keinen Zugriff mehr. Wenn wir jetzt zum Beispiel erneut die Zeichenkette \"password\" benötigten, müssten wir sie auch erneut eintippen. Wie es ändern können, dass uns Objekte längerfristig zur Verfügung stehen, wollen wir uns jetzt anschauen. 3.2 Erzeugung von referenzierbaren Objekten Mit dem Operator &lt;- lässt sich ein referenzierbares Objekt erstellen. Das bedeutet, dass das Objekt an einen Namen gebunden wird: x_test &lt;- 3 Das Objekt lässt sich nun über den Namen aus dem Speicher abrufen: x_test ## [1] 3 Wenn wir x_test &lt;- 3 ausführen, passiert formal eigentlich Folgendes: Es wird im Speicher ein Objekt mit dem Wert 3 erzeugt. Es wird der Name x_test an dieses Objekt gebunden, sodass zu diesem Objekt mit dem Namen x_test referiert werden kann bzw. bei Aufruf von x_test der Wert zurückgegeben wird. Über den Namen, welcher nun an das Objekt gebunden ist, können wir dieses jetzt dauerhaft abrufen (referenzieren). 3.2.1 Anmerkung Namen Für Namen dürfen alle Buchstaben und Zahlen verwendet werden, sowie die beiden Sonderzeichen _ und ., wobei diese nicht am Anfang stehen dürfen. Beispiel: x_1 &lt;- 3 Aber: _x_1 &lt;- 3 ## Error: &lt;text&gt;:1:2: unexpected symbol ## 1: _x_1 ## ^ Bemerkung: Man sollte sich bei den Buchstaben nur auf a,…,z bzw. A,.., Z beschränken, auch wenn je nach lokalem Setting z.B. auch andere Buchstaben wie ä zulässig sind. 3.2.2 Rechnungen mit Werten von Objekten Das über seinen Namen referenzierbare Objekt steht für alle weiteren Berechnungen und Operationen zur Verfügung: x_test + 2 ## [1] 5 Das Ergebnis dieses Ausdrucks ist ein neues numerisches Objekt. Dieses kann für spätere Zwecke erneut an einen Namen gebunden werden: y_test &lt;- x_test + 2 y_test ## [1] 5 Unser Speicher sieht aktuell so aus: Zwar haben wir für die Berechnung auch eine zwei im Speicher angelegt, diese ist aber nicht an einen Namen gebunden. Die drei und die fünf hingegen schon. Wenn wir nun x_test und y_test aufrufen, bekommen wir jeweils das entsprechende Objekt zurück. 3.2.3 Namen überschreiben ACHTUNG! - Verwendet man denselben Namen noch einmal, geht die ursprüngliche Referenz verloren: y_test &lt;- log(y_test) Wenn wir jetzt das Objekt zum Namen y_test abfragen, sehen wir Folgendes: y_test ## [1] 1.609438 Das ursprüngliche Objekt zum Namen y_test steht uns nicht mehr zur Verfügung und ist somit unwiederbringlich verloren. Führt man die Codezeile y_test &lt;- log(y_test) jetzt noch einmal aus, so wird y_test wieder an ein anderes Objekt gebunden. Durch dieses Verhalten können wir nie sicher vorhersagen, an welches Objekt y_test momentan gebunden ist. Deswegen sollte man immer neue Namen vergeben und diese nicht doppelt verwenden. 3.2.4 Objekte löschen Wir haben mittlerweile ein paar Objekte im Speicher angelegt und an Namen gebunden. Mit ls() kann man diese abrufen: ls() ## [1] &quot;alter_moni&quot; &quot;alter_tom&quot; &quot;countdown&quot; ## [4] &quot;D&quot; &quot;df_lineup&quot; &quot;DJ_Alter&quot; ## [7] &quot;DJ_Geburtsjahr&quot; &quot;DJ_Name&quot; &quot;DJ_Vinyl&quot; ## [10] &quot;i&quot; &quot;is.positive&quot; &quot;M&quot; ## [13] &quot;name&quot; &quot;name_bundeskanzler&quot; &quot;p&quot; ## [16] &quot;pow&quot; &quot;profil_marie&quot; &quot;q&quot; ## [19] &quot;quadrat&quot; &quot;starwars&quot; &quot;theendoftheworld&quot; ## [22] &quot;un_lambda&quot; &quot;v1&quot; &quot;v1_log&quot; ## [25] &quot;v2&quot; &quot;x&quot; &quot;X&quot; ## [28] &quot;x_1&quot; &quot;x_test&quot; &quot;y&quot; ## [31] &quot;y_test&quot; &quot;z&quot; &quot;zahl&quot; Mit rm() kann man unnötige Objekte über deren Namen entfernen: rm(y_test) Wenn ihr gleich alle angelegten, referenzierbaren Objekte aus dem Speicher entfernen wollt: rm(list = ls()) 3.3 Logische Werte und Operationen Die Werte Wahr und Falsch werden in R mit TRUE und FALSE repräsentiert. Es stehen die elementaren Booleschen Operationen zur Verfügung. Operator Bedeutung ! Negation &amp; Und | Oder p &lt;- TRUE !p ## [1] FALSE q &lt;- FALSE (p | q) ## [1] TRUE 3.3.1 Der “logische” Wert NA Neben Wahr und Falsch existiert noch die logische Konstante NA, welche für einen unbestimmten aber bestimmbaren Wert steht (not assigned, not available yet). Dieser Wert wird z.B. universell für alle atomaren Datentypen für die Codierung von Fehlwerten (missings) verwendet. theendoftheworld &lt;- NA 3.3.2 Vergleichs-Operationen Logische Werte spielen in R an verschiedenen Stellen eine große Rolle, da sie z.B. beschreiben, ob bestimmte Vergleiche wahr oder falsch sind. Operator Bedeutung == Gleich? != Ungleich? &gt; / &lt; Größer / Kleiner? &gt;= / &lt;= Größer / Kleiner gleich? alter_tom &lt;- 21 alter_moni &lt;- 24 alter_tom &gt; alter_moni ## [1] FALSE 3.4 Zeichenketten (character strings) Neben Zahlen und logischen Werten werden wir auch Zeichenketten begegnen bzw. benötigen. Diese können auf zweierlei Art zugewiesen werden: &quot;Tom&quot; ## [1] &quot;Tom&quot; &#39;Moni&#39; ## [1] &quot;Moni&quot; name_bundeskanzler &lt;- &quot;Olaf Scholz&quot; name_bundeskanzler ## [1] &quot;Olaf Scholz&quot; 3.5 Klasse eines Datenobjektes Die Klasse bzw. der Datentyp eines Objekts lässt sich mit der Funktion class() ermitteln oder aber spezifisch/logisch prüfen. class(alter_moni) ## [1] &quot;numeric&quot; is.numeric(alter_moni) ## [1] TRUE 3.6 Spezielle Werte Die leere Menge wird in R mit dem Wert NULL repräsentiert und dient ganz verschiedenen Zwecken wie z.B. der Initialisierung einer Variablen: z &lt;- NULL z ## NULL Division durch 0 ist “erlaubt” und liefert den speziellen Wert Inf zurück. 100/0 ## [1] Inf In R wird ein nicht bestimmbarer Wert (vgl. unbestimmter aber bestimmbarer Wert ‘NA’) durch NaN (not a number) angegeben. 3.7 Prüfe dich selbst Von dieser Sitzung solltest du Folgendes mitgenommen haben: Du solltest verstanden haben, warum man verschiedene Datentypen unterscheidet. Du solltest die drei grundlegenden Wege, Informationen zu repräsentieren, und die dazugehörigen Datentypen nennen können. Du solltest verstanden haben, wie man Objekte an einen Namen bindet und warum das nützlich sein kann. Du solltest die elementaren Booleschen (logischen) Operationen in R schreiben können. 3.8 Literaturverweise Ergänzend R-Intro Kapitel 1 &amp; 2 Hands-On Programming with R Kapitel 2 (Ohne 2.4 &amp; 2.5) Weiterführend Advanced R Kapitel 2 und 12 Chambers (2014) Wickham (2019) (n.d.) Grolemund (2014) References "],["strukturierte-datentypen.html", "Kapitel 4 Strukturierte Datentypen 4.1 Vektoren 4.2 Matrizen 4.3 Listen 4.4 Data Frames 4.5 Prüfe dich selbst", " Kapitel 4 Strukturierte Datentypen Basierend auf den einfachen (atomaren) Datentypen existieren in R die folgenden grundlegenden Datenstrukturen. Datenstruktur Beschreibung vector Sequenz gleicher Datentypen matrix Verallg. Vektor in 2 Dimensionen array Verallg. Vektor mit beliebigen Dimensionen list Sequenz ungleicher Datentypen data frame Spezielle Liste mit Vektoren gleicher Länge Schema: Dimension Homogen Heterogen 1-Dim. vector list 2-Dim. matrix data frame k-Dim. array Vektoren und Matrizen sind eine strukturierte Zusammenstellung von Daten gleichen Typs. Ein Vektor kann zum Beispiele eine Reihe von integer Werten bündeln, dann aber keine zusätzlichen logischen Werte oder Zeichenketten aufnehmen. Im Gegensatz dazu erlauben es uns Listen und Data Frames, auch Daten unterschiedlichen Typs zu bündeln. In diesem Kapitel wollen wir uns damit auseinandersetzen, was für Implikationen die hier skizzierten Eigenschaften der verschiedenen Datenstrukturen auf deren Anwendung haben. Damit die Datenstruktur für euch auch visuell an Gestalt gewinnt, hier eine vereinfachte Darstellung mit den zentralen Eigenschaften der Datenstrukturen. Sie ist nicht in allen Hinsichten korrekt, soll aber dazu dienen, die grundlegenden Unterschiede der verschiedenen Datenstrukturen zu veranschaulichen. Abb. 4.1: Strukturierte Datentypen 4.1 Vektoren Vektoren sind sequentiell geordnete Folgen von Werten gleichen Typs. Vektoren können auf ganz unterschiedliche Art erzeugt werden. Beispiel: Informationen zum Lineup für die Clubnacht heute. Mit der Funktion c() (kurz für ‘concatenate’ / ‘combine’). DJ_Alter &lt;- c(34,45,28,25,20) DJ_Name &lt;- c(&quot;DJ Puma&quot;,&quot;Cabanne&quot;,&quot;Molly&quot;,&quot;Echoton&quot;,&quot;cv313&quot;) DJ_Vinyl &lt;- c(F,T,T,F,F) DJ_Alter ## [1] 34 45 28 25 20 DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE Anmerkung: Die DJs gibt es wirklich und es lohnt sich mal reinzuhören :). Das Alter und ob die Personen mit Vinyl auflegen oder nicht, ist allerdings frei erfunden. Ganz einfach können wir Vektoren auch mit dem Colon-Operator : erzeugen, welcher Zahlenfolgen mit Inkrement 1/-1 generiert. 1:4 ## [1] 1 2 3 4 countdown &lt;- 10:0 countdown ## [1] 10 9 8 7 6 5 4 3 2 1 0 -1.2:5 ## [1] -1.2 -0.2 0.8 1.8 2.8 3.8 4.8 Allgemeinere Folgen kann man mit seq() erzeugen: seq(from = 1, to = 3, by = 0.5 ) ## [1] 1.0 1.5 2.0 2.5 3.0 Auch sehr nützlich: rep(x = c(&quot;Nein!&quot;,&quot;Doch!&quot;), times = 3 ) ## [1] &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; &quot;Nein!&quot; &quot;Doch!&quot; 4.1.1 Abfragen von Werten durch Subsetting von Vektoren Mit dem Operator [] können einzelne Elemente eines Vektors abgefragt werden. Hier zum Beispiel die Indexposition 2: DJ_Alter[2] ## [1] 45 Der Operator ist aber tatsächlich ein “Subset”-Operator und damit wesentlich flexibler und sehr mächtig: DJ_Name[c(1,3)] ## [1] &quot;DJ Puma&quot; &quot;Molly&quot; DJ_Name[-c(1,3)] ## [1] &quot;Cabanne&quot; &quot;Echoton&quot; &quot;cv313&quot; Der Subset-Operator ermöglicht es uns also auch eine Teilmenge des Vektors nach bestimmten Kriterien abzufragen. Hier zum Beispiel die Teilmenge derjenigen Werte, welche einen entsprechenden Index haben. Man sollte [] als einen Operator verstehen, welcher von links auf einen Vektor angewendet wird. Übergibt man [] einen logischen Vektor (passender Länge), so werden alle korrespondierenden “wahren” Elemente eines Vektors ermittelt. Dies ist tatsächlich eine der häufigsten Verwendungen von []: DJ_Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; DJ_Vinyl ## [1] FALSE TRUE TRUE FALSE FALSE DJ_Name[DJ_Vinyl] ## [1] &quot;Cabanne&quot; &quot;Molly&quot; 4.1.2 Vektorisierte Operationen Alle atomaren Datentypen sind tatsächlich Vektoren der Länge 1 zahl &lt;- 1 p &lt;- TRUE name &lt;- &quot;Tom&quot; length(zahl) ## [1] 1 length(p) ## [1] 1 length(name) ## [1] 1 Analog agieren dann (fast) alle Operationen, welche für atomare Datentypen definiert sind, als vektorisierte Operation, d.h. elementweise: x &lt;- c(1,2,3) y &lt;- c(2,1,3) x + y ## [1] 3 3 6 x + 1 ## [1] 2 3 4 log(x) ## [1] 0.0000000 0.6931472 1.0986123 DJ_Alter &gt; 21 ## [1] TRUE TRUE TRUE TRUE FALSE Der letzte Ausdruck wertet elementweise aus, ob das jeweilige Alter größer als 21 ist und bildet das Ergebnis anschließend auf einen logischen Vektor mit korrespondierender Länge ab. Zur Illustration der folgenden Beispiele brauchen wir noch einen weiteren numerischen Vektor. Da wir jetzt wissen, wie man vektorisierte Operationen vollführt, können wir ganz einfach einen Vektor mit den annäherenden Geburtsjahren der Personen aus deren Alter berechnen: DJ_Geburtsjahr &lt;- 2022 - DJ_Alter DJ_Geburtsjahr ## [1] 1988 1977 1994 1997 2002 4.1.3 Operationen auf Vektoren Abhängig vom Datentyp eines Vektors existieren verschiedene Funktionen, welche als Argument einen Vektor nehmen und auf ein Resultat abbilden. Operation Beschreibung length() Länge eines Vektors mean() Durchschnittswert eines num. Vektors max() Maximum eines num. Vektors any() Ist irgendein Wert eines log. Vektors wahr? mean(DJ_Alter) ## [1] 30.4 any(DJ_Vinyl) ## [1] TRUE 4.2 Matrizen Die Datenstruktur einer Matrix verallgemeinert das Konzept eines Vektors in zwei Dimensionen. Eine Matrix kann z. B. durch einen Vektor mit dem Befehl matrix() generiert werden: M &lt;- matrix(data = 1:9, nrow = 3, ncol = 3, byrow = TRUE ) M ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 Das Ergebnis gibt uns schon einen Hinweis darauf, wie wir die Matrix “subsetten” können. In den eckigen Klammern ist jeweils der Index vermerkt, welche Zeile bzw. Spalte dargestellt wird. Die Indizierung erfolgt dann ähnlich zu Vektoren: M[1,2] ## [1] 2 Lassen wir ein Argument offen und geben zum Beispiel nur einen Zeilenindex an, evaluiert der Ausdruck entsprechend zur gesamten angegebenen Zeile. M[2, ] ## [1] 4 5 6 Analog können wir auch nur das Argument für die Spalte angeben: M[ ,1] ## [1] 1 4 7 4.2.1 Benennung von Spalten Mit der Funktion colnames() lassen sich die Spalten (columns) einer Matrix benennen/ändern sowie auch abrufen. colnames(M) &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) M ## A B C ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 colnames(M) ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; Die Funktion rownames() macht dann gleiches für die Zeilen einer Matrix. Über die Spaltennamen können wir nun auch auf die Elemente der Matrix zugreifen: M[ ,&quot;B&quot;] ## [1] 2 5 8 4.2.2 Erzeugung von Matrizen aus Vektoren Zwei Vektoren können mit der Funktion cbind() in eine Matrix überführt werden. D &lt;- cbind(DJ_Alter,DJ_Geburtsjahr) D ## DJ_Alter DJ_Geburtsjahr ## [1,] 34 1988 ## [2,] 45 1977 ## [3,] 28 1994 ## [4,] 25 1997 ## [5,] 20 2002 Analog können mit rbind() zwei Vektoren als Zeilen zu einer Matrix gebunden werden. Achtung! Achtet darauf, dass die zwei Vektoren den gleichen atomaren Datentypen haben, sonst wird der “höherwertigere” der beiden umgewandelt. Wenn ihr zum Beispiel einen character Vector und einen vom Typ logical mit der Funktion cbind() verbindet, erhaltet ihr eine Matrix mit ausschließlich character Werten. 4.3 Listen Eine Liste ist ein “verallgemeinerter Vektor” und lässt als Elemente beliebige Werte oder Datenstrukturen zu: profil_marie &lt;- list(Name = &quot;Marie&quot;, Freunde = c(&quot;Daphne&quot;,&quot;Peer&quot;), Alter = 24 ) profil_marie ## $Name ## [1] &quot;Marie&quot; ## ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peer&quot; ## ## $Alter ## [1] 24 Die Elemente können auch gleich einem Namen zugeordnet werden. 4.3.1 Indizierung von Listen Die Indizierung von Listen funktioniert etwas anders als bei den homogenen Datenstrukturen, da die Liste eigentlich nur Referenzen auf Objekte sammelt. Wenn wir die einzelnen Objekte für Operationen verwenden wollen, nutzen wir am besten den $ (Dollar) Operator. So können wir die Objekte, auf welche die Liste verweist, direkt ‘ansprechen’. profil_marie$Name ## [1] &quot;Marie&quot; profil_marie$Freunde ## [1] &quot;Daphne&quot; &quot;Peer&quot; Die Verwendung des mittlerweile altbekannten Subset-Operators ist auch möglich. Allerdings müssen wir hier die verschachtelte Struktur der Liste immer mitdenken, was es deutlich komplizierter macht. Hier ein Beispiel: profil_marie[2] ## $Freunde ## [1] &quot;Daphne&quot; &quot;Peer&quot; Mit diesem Aufruf erhalten wir einen Verweis, welcher auf einen Vektor zeigt, welcher die Zeichenketten “Daphne” und “Peer” beinhaltet. profil_marie[[2]][1] ## [1] &quot;Daphne&quot; Diese Funktion bezieht sich im ersten Teil profil_marie[[2]] nun tatsächlichn auf den Vektor, auf welchen die Referenz zeigt. Auf diesen wird anschließend nun noch mal der Subset-Operator für die erste Position angewandt (Unser_Vektor[1]). So erhalten wir das erste Element des Vektors (was wiederum ein ein-elementiger Vektor ist). Deutlich einfacher ist hingegen die Indizierung mithilfe des Dollar-Operators und den Namen der Objekte. Damit kommen wir viel lesbarer zum selben Ergebnis: profil_marie$Freunde[1] ## [1] &quot;Daphne&quot; Falls ihr noch tiefer in das Subsetting von Listen einsteigen wollt, empfiehlt sich das Kapitel “Subsetting” aus dem Buch Advanced R. 4.4 Data Frames Die für statistische Zwecke häufigste und wichtigste Datenstruktur ist die einer Datentabelle, ein sogenanntes dataframe. Diese können wir ganz einfach aus Vektoren erzeugen: df_lineup &lt;- data.frame(Name = DJ_Name, Alter = DJ_Alter ) df_lineup ## Name Alter ## 1 DJ Puma 34 ## 2 Cabanne 45 ## 3 Molly 28 ## 4 Echoton 25 ## 5 cv313 20 4.4.1 Indizierung von Datentabellen Analog zu Matrizen: df_lineup[3, ] ## Name Alter ## 3 Molly 28 df_lineup[ ,2] ## [1] 34 45 28 25 20 Analog zu Listen können wir die Spalten auch über ihren Namen anwählen. df_lineup$Name ## [1] &quot;DJ Puma&quot; &quot;Cabanne&quot; &quot;Molly&quot; &quot;Echoton&quot; &quot;cv313&quot; 4.4.2 Aufname weiterer Variablen/Spalten Analog zu Matrizen können wir mit der Funktion cbind() Vektoren als Spalten eines bereits bestehenden Data Frames aufnehmen. df_lineup &lt;- cbind(df_lineup,DJ_Vinyl) df_lineup ## Name Alter DJ_Vinyl ## 1 DJ Puma 34 FALSE ## 2 Cabanne 45 TRUE ## 3 Molly 28 TRUE ## 4 Echoton 25 FALSE ## 5 cv313 20 FALSE Alternativ können wir eine Spalte anwählen, welche es noch nicht gibt und diese anschließend an einen Vektor binden. df_lineup$Geburtsjahr &lt;- DJ_Geburtsjahr df_lineup ## Name Alter DJ_Vinyl Geburtsjahr ## 1 DJ Puma 34 FALSE 1988 ## 2 Cabanne 45 TRUE 1977 ## 3 Molly 28 TRUE 1994 ## 4 Echoton 25 FALSE 1997 ## 5 cv313 20 FALSE 2002 4.4.3 Operationen auf Datentabellen Die Objekte, welche in einer Datentabelle gespeichert sind, können wir, wie alle anderen Objekte auch, in Funktionsaufrufen weiterverwenden. mean(df_lineup$Alter) ## [1] 30.4 4.5 Prüfe dich selbst Du solltest die vier grundlegenden strukturierten Datentypen nennen und unterscheiden können. Du solltest wissen, auf welche Weisen du auf die Elemente der unterschiedlichen strukturierten Datentypen zugreifen kannst. Du solltest verstanden haben, welche Möglichkeiten es gibt, verschiedene Teilmengen eines strukturierten Datentyps abzufragen. "],["funktionen.html", "Kapitel 5 Funktionen 5.1 Eigenschaften 5.2 Aufbau 5.3 Verschachtelungen 5.4 Pipes 5.5 Default Werte 5.6 Help Fenster 5.7 Prüfe dich selbst", " Kapitel 5 Funktionen Zur Erinnerung: In R wird grundsätzlich zwischen Funktionen und Objekten unterschieden. In diesem Kapitel wird es um die Grundlagen im Umgang mit Funktionen gehen. Technisch gesehen handelt es sich bei R um eine funktionale Programmiersprache. Das heißt, einfach formuliert, dass Problemlösungen durch Funktionen erfolgen.3 5.1 Eigenschaften Die meisten Funktionen in R haben bestimmte Eigenschaften: 1. Funktionen sind “eigenständig”. Der Output einer Funktion hängt lediglich von seinem Input ab. Wird eine Funktion mit den gleichen argumentativen Werten zweimal ausgeführt, ist der Output in beiden Durchgängen identisch. Ausnahmen bilden Funktionen, die auf (Pseudo-) Zufallsverfahren beruhen, wie z.B. rnorm(). 2. Funktionen helfen beim Erreichen bestimmter Ziele. Funktionen sollten vom Output her gedacht werden (Welches Ziel soll erreicht werden?). Zur Auswahl einer passenden Funktion muss ein Ziel formuliert werden. 3. Funktionen bestehen im Wesentlichen aus einer Komposition von Base-Funktionen. In R sind sogenannte primitive Funktionen definiert und bilden die kleinste Einheit von Funktionen. Beispiel: mean ## function (x, ...) ## UseMethod(&quot;mean&quot;) ## &lt;bytecode: 0x000001d098174c60&gt; ## &lt;environment: namespace:base&gt; Alle anderen Funktionen bestehen aus einer Komposition dieser primitiven Funktionen. Beispiel: factor ## function (x = character(), levels, labels = levels, exclude = NA, ## ordered = is.ordered(x), nmax = NA) ## { ## if (is.null(x)) ## x &lt;- character() ## nx &lt;- names(x) ## if (missing(levels)) { ## y &lt;- unique(x, nmax = nmax) ## ind &lt;- order(y) ## levels &lt;- unique(as.character(y)[ind]) ## } ## force(ordered) ## if (!is.character(x)) ## x &lt;- as.character(x) ## levels &lt;- levels[is.na(match(levels, exclude))] ## f &lt;- match(x, levels) ## if (!is.null(nx)) ## names(f) &lt;- nx ## if (missing(labels)) { ## levels(f) &lt;- as.character(levels) ## } ## else { ## nlab &lt;- length(labels) ## if (nlab == length(levels)) { ## nlevs &lt;- unique(xlevs &lt;- as.character(labels)) ## at &lt;- attributes(f) ## at$levels &lt;- nlevs ## f &lt;- match(xlevs, nlevs)[f] ## attributes(f) &lt;- at ## } ## else if (nlab == 1L) ## levels(f) &lt;- paste0(labels, seq_along(levels)) ## else stop(gettextf(&quot;invalid &#39;labels&#39;; length %d should be 1 or %d&quot;, ## nlab, length(levels)), domain = NA) ## } ## class(f) &lt;- c(if (ordered) &quot;ordered&quot;, &quot;factor&quot;) ## f ## } ## &lt;bytecode: 0x000001d098b994a8&gt; ## &lt;environment: namespace:base&gt; 5.2 Aufbau Funktionsaufrufe folgen i.d.R. dem Schema Funktionsname(Argument 1 = ..., Argument 2 = ..., ...) Bei den Argumenten handelt es sich meistens… um ein oder mehrere Objekte, auf die sich die Funktion bezieht. Optionen, die die Verarbeitung des Objekts beeinflussen. Beispiel: rep(x = 1:3, # x ist hier das Objekt times = 2) # times ist die Option Die Reihenfolge der Argumente in einer Funktion sind fest definiert. rep(3, 2) ## [1] 3 3 rep(2, 3) ## [1] 2 2 2 In diesem Fall wird das erste Argument als Objekt (x) und das zweite als Option (times) erkannt. Die Reihenfolge der Argumente ist aber nur dann relevant, wenn die Argumente nicht benannt werden. Werden die Argumente hingegen benannt, wird die interne Reihenfolge überschrieben: rep(x = 2, times = 3) ## [1] 2 2 2 rep(times = 3, x = 2) ## [1] 2 2 2 Wichtiger Hinweis! Es lohnt sich immer, die Argumente in einer Funktion zu benennen. Nicht nur erleichtert es euch, den Code auch nach langer Zeit noch zu verstehen, sondern auch anderen wird das Lesen eures Codes erleichtert. 5.3 Verschachtelungen Bei dem Output von Funktionen handelt es sich (fast) immer um Objekte. Diese Objekte können natürlich direkt wieder einer Funktion übergeben werden. Diese Eigenschaft ermöglicht es, Funktionen zu schachteln. Hieraus ergibt sich, dass R diese Schachtelungen von Innen nach Außen auflöst. Im folgenden Beispiel wird also zunächst der Mittelwert des Vektors bestimmt. Im Anschluss wird der Absolutbetrag hiervon genommen, usw. round(log(abs(mean(c(-1,-2,-3,-4))))) ## [1] 1 Dieses Beispiel ist noch relativ gut überschaubar. Im Arbeiten werden diese Ketten jedoch schnell komplexer und unübersichtlich. Eine Alternative hierzu bieten sogenannte Pipes. 5.4 Pipes Pipes bilden die Alternative zu geschachtelten Funktionen. Erstmals eingeführt wurden diese in der der Package-Familie des Tidyverse (%&gt;%, siehe Kapitel zum Tidyverse). Seit der R Version 4.1.0 ist jedoch auch ein nativer Pipe-Operator verfügbar (|&gt;). Pipes funktionieren analog zu geschachtelten Funktionen: Ein Objekt (X) wird an eine Funktion (z.B. mean()) übergeben. Die Funktion gibt ein Objekt zurück. Das entstandene Objekt wird an eine weitere Funktion übergeben. Auch diese Funktion gibt ein Objekt zurück. usw. Code Beispiel: X &lt;- c(-1,-2,-3,-4) X |&gt; mean() |&gt; abs() |&gt; log() |&gt; round() ## [1] 1 An dem Code Beispiel werden die Vorteile von Pipes nochmal deutlich. Die Code-Sequenz kann von oben nach unten gelesen werden (wie eine Geschichte). Außerdem wird deutlicher, was mit den Daten Passiert und der Vorgang kann schnell, Durch das Anpassen von Argumenten abgewandelt werden. Pro Tipp Um einen Pipe-Operator einzufügen, kann die Tastenkombination Str + Umschalt + m bzw. CMD + Umschalt + m genutzt werden. Will man statt des nativen Operators den Operator aus dem Tidyverse nutzen, kann das über Tools \\(\\rightarrow\\) Global Options \\(\\rightarrow\\) Code \\(\\rightarrow\\) Use native pipe operator geändert werden. 5.5 Default Werte Die meisten Funktionen in R verfügen über sogenannte Default Werte. Hierbei handelt es sich um voreingestellte Werte, die für bestimmte Argumente verwendet werden, wenn bei diesen kein Wert übergeben wird. Für die Funktion round() ist ein Default Wert von 0 für das Argument digits hinterlegt. Entsprechend sind die folgenden zwei Codezeilen funktional identisch: round(x = pi) ## [1] 3 round(x = pi, digits = 0) ## [1] 3 In manchen Fällen sind aber auch logische Werte als Default Werte hinterlegt. In der Funktion sd() ist das Argument na.rm enthalten. Enthält der Vektor, der der Funktion übergeben wird ein NA, wird die Funktion auch NA zurückgeben. Schließlich ist ein Wert unbekannt und daher kann auch nicht mit Sicherheit eine Standardabweichung bestimmt werden. Mit dem Argument na.rm können vor der Berechnung alle NA entfernt werden. Hier ist ein logischer Default Wert von FALSE vorgegeben. x &lt;- c(1,2,3,NA) sd(x) ## [1] NA # Das entspricht: sd(x, na.rm = FALSE) ## [1] NA # Mit geändertem Wert: sd(x, na.rm = TRUE) ## [1] 1 5.6 Help Fenster Natürlich muss und soll niemand alle Argumente zu allen Funktionen auswendig lernen. R stellt hierzu bereits intern ein hilfreiches Hilfe-Fenster zur Verfügung. Für jede Funktion kann dieses über ?Funktionsaufruf aufgerufen werden. Abb. 5.1: Help Fenster Die Description gibt detailliert Auskunft über die Funktionsweise der Funktion. Hier ist das “Ziel” der Funktion festgeschrieben, das vor der Auswahl der Funktion von den Nutzer:innen formuliert werden sollte. Unter Usage sind die verschiedenen Argumente und ihre interne Reihenfolge (siehe Kapitel 5.2) bereits aufgeführt. Die hier aufgeführten Werte für die Argumente sind die hinterlegten Default Werte. Unter Arguments können die Beschreibungen der einzelnen Argumente gefunden werden. Hier sollte besonders darauf geachtet werden, welcher Datentyp als Wert übergeben werden muss. Details enthält Hinweise zur internen Berechnung von Werten, Verfahren, etc. Das ist dann besonder relevant, wenn es für die Berechnung von Kennwerten keine einheitlichen Konventionen gibt. In der Sektion See also sind Verweise zu anderen Funktionen oder Literaturhinweise vermerkt. Schließlich finden sich im letzten Abschnitt unter Examples konkrete Code Beispiele für die Anwendung der Funktion. Hinweis! Je nach Package und Entwickler*in der Funktion ist das korrespondierende Hilfe-Fenster hilfreicher oder weniger hilfreich. Manchmal sind die Beschreibungen sehr kryptisch. Im Zweifel lohnt sich immer eine Google-Suche für euer spezifisches Problem (Stack Overflow!). Und im Zweifel gilt: Immer mit der Ruhe und keine Panik ;-) 5.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest den typischen Aufbau von Funktionen kennen. Du solltest Pipes kennen, verstehen und rudimentär anwenden können. Du solltest wissen, dass es Default Werte gibt und wie du herausfindest, welche Werte als solche hinterlegt sind. Du solltest dich im Hilfefenster zurechtfinden. Für die technischen Details, siehe Wickham, H.: Advanced R, Chapter 6, Introduction.↩︎ "],["packages.html", "Kapitel 6 Packages 6.1 Packages installieren und laden 6.2 needs()", " Kapitel 6 Packages Alle Probleme und Anwendungen lassen sich, jedenfalls theoretisch, mit den Basis-Funktionen von R realisieren. Je weiter in der Datenanalyse fortgeschritten wird, desto komplexer werden jedoch die Probleme. Wiederkehrende Probleme lassen sich oft lösen, indem selber Funktionen geschrieben werden. Bei vielen Programmiersprachen sind hierbei vor allem zwei Optionen der Fall: (Fast) Alle Probleme waren schonmal da. (Fast) Alle Probleme treten wiederholt auf. Damit sind andere User:innen (wahrscheinlich) bereits auf das gleiche Problem gestoßen und haben entsprechende Funktionen geschrieben, um das Problem zu lösen. Sie können ihre Funktionen in sogenannten Packages der Allgemeinheit zur Verfügung stellen. So kann mithilfe dieser Packages der Funktionsumfang von R praktisch beliebig erweitert werden. 6.1 Packages installieren und laden Bevor auf die Funktionen des Packages zurückgegriffen werden kann, muss dieses auf dem Computer installiert werden. Analog könnte man darunter auch das Lernen von neuen Vokabeln verstehen. Die Installation erfolgt über die Funktion install.packages(). Das einzige Argument ist der Name des zu ladenden Packages als Character. install.packages(&quot;tidyverse&quot;) Ist das Package installiert, muss es zunächst noch geladen werden, bevor es benutzt werden kann. Hierfür gibt es zwei Funktionen: library(tidyverse) require(tidyverse) In der Praxis macht es meist keinen Unterschied, welche Funktion genutzt wird. Das einzige Argument ist bei beiden Funktionen der Name des Packages als Name (ohne Anführungszeichen). require() wurde für die Anwendung in Funktionen entwickelt. Wird ein Package hiermit geladen, wird ein FALSE zurückgegeben, wenn das Package nicht installiert ist. require(tidyverse) library() gibt eine Fehlermeldung zurück, wenn das Package nicht installiert ist. Im Alltagsgebrauch wird diese Funktion empfohlen. library(tidyverse) 6.2 needs() Gerade im Arbeitsfluss ist die oben beschriebene Vorgehensweise lästig. Auf dieses Problem sind bereits vorher User:innen gestoßen und haben entsprechend ein Package geschrieben, was den Arbeitsfluss erleichtern soll. Dieses Package heißt (sehr passend) Needs und lädt nur eine Funktionen: needs(). Mit needs() können, mit Komma getrennt, ein oder mehr Packages als Namen (ohne Anführungszeichen) übergeben werden. Beim Ausführen wird zunächst überprüft, ob das Package installiert ist. Ist es installiert, wird es geladen. Ist es nicht installiert, wird es installiert und anschließend geladen. # install.packages(&quot;needs&quot;) library(needs) needs(haven, tidyverse, lubridate ) Im Arbeitsfluss kann dann ein Package, was benötigt wird, einfach in die Funktion geschrieben und ausgeführt werden. Hinweis! Beim ersten Laden fragt needs, ob es sich selber laden soll, wenn es gebraucht wird. Wählt man yes aus, wird die Zeile library(needs) nicht benötigt. Diese Funktionsweise ist ein wenig “buggy”; heißt: manchmal funktioniert das nicht. Wir empfehlen, einfach das Package zu Beginn zu laden und sich nicht hierauf zu verlassen. "],["dateimanagement.html", "Kapitel 7 Dateimanagement 7.1 Absolute und relative Dateipfade (Exkurs) 7.2 R Projects 7.3 Dateien einlesen", " Kapitel 7 Dateimanagement RStudio bietet intern bereits ein gutes Tool, um Dateien auf der Festplatte zu verarbeiten. Dateien lassen sich hier löschen, umbenennen, verschieben, kopieren oder neue Ordner hinzufügen. 7.1 Absolute und relative Dateipfade (Exkurs) Um Dateien in R zu laden, muss zumeist ein Datenpfad angegeben werden, der zu der zu ladenden Datei führt. Der Datenpfad ist dabei zunächst entsprechen lang: df_example &lt;- read.csv(file = &quot;/Users/username/Documents/GitHub/r-kurs/sitzung/data/strata.csv&quot;) Diese langen Datenpfade können mithilfe von Working Directories (WD) gelöst werden. Diese können mit der Funktion setwd() eingerichtet werden. setwd(dir = &quot;/Users/username/Documents/GitHub/r-kurs/sitzung&quot;) Im Zweifel kann die WD dann mithilfe von getwd() abgerufen werden. Wurde eine WD festgelegt, kann der Datenpfad nun bei dem Ort beginnen, der über die setwd() Funktion festgelegt wurde. df_example &lt;- read.csv(file = &quot;data/strata.csv&quot;) Der Nachteil dieser Herangehensweise ist, dass die WD global für alle Arbeitsschritte festgelegt wird. Sollen aber WDs für einzelne “Projekte” festgelegt werden, sollten RProjects genutzt werden. 7.2 R Projects Abb. 7.1: R Project Logo Um ein R Project anzulegen, sollten folgende Schritte befolgt werden: Projekt-Ordner anlegen (Name des Ordners wird zum Projekt-Namen) In RStudio über Projects (oben rechts) New Project... wählen New Project \\(\\Rightarrow\\) Existing Directory \\(\\Rightarrow\\) Erstellten Ordner aus 1. wählen \\(\\Rightarrow\\) Create Ein Projekt kann dann immer über die .RProj-Datei geöffnet werden. Vorteile von Projekten: Wechsel von Projekten einfach möglich (WD muss nicht immer neu festgelegt werden) Code wird transportabel Deutlich übersichtlicher als lose Ordnerstruktur RHistory wird projektbezogen gespeichert 7.3 Dateien einlesen In R sind grundsätzlich alle Datei-Typen einlesbar bzw. verarbeitbar. Hierunter zählen z.B. Datenformat File-Extension Bemerkung RData/RDS .Rda bzw. .Rds Native R-Datenformate CSV .csv Comma-Seperated Values Text/ASCII .txt Reines Textfile XLS .xls bzw. .xlsx EXCEL-Datenformat SAV .sav SPSS-Datenformat DTA .dta Stata-Datenformat R .R Speicherung als R-Skript R interne Dateien, sowie verschiedene Text-Formate (.csv, .tsv, .txt, …) können bereits mit R Base eingelesen werden. Komplexere Datenformate (Excel, Stata, SPSS) benötigen bestimmte Packages. 7.3.1 R-interne Dateien Objekte in der R Umgebung lassen sich explizit als Datei auf dem Computer speichern. Hierzu gibt es zwei mögliche Datei-Formate: .Rda (R Data) Mithilfe der Funktion save() können R Objekte gespeichert werden. df_data &lt;- data.frame(x = 1:10, # Objekte anlegen y = 10:1) x &lt;- 4 save(list = c(&quot;df_data&quot;,&quot;x&quot;), # Objekt speichern (als Liste) file = &quot;data/example.Rda&quot;) # Datenpfad Die Funktion load lädt die gespeicherten Objekte wieder in die Umgebung. load(file = &quot;data/example.Rda&quot;) Vorteil Mehrere Objekte speicherbar Nachteil Objekte werden mit gleichem Namen wieder geladen .Rds (R Data Single) Das .Rds-Format erlaubt das speichern eines Objektes. Das Speichern erfolgt ähnlich wie bei den .Rda-Formaten. saveRDS(df_data, file = &quot;data/example.Rds&quot;) Beim Laden wird ein neuer Name für das Objekt festgelegt. df_new &lt;- readRDS(&quot;data/example.Rds&quot;) Vorteil An neuen Namen bindbar Nachteil Nur ein Objekt kann gespeichert/geladen werden 7.3.2 R-externe Dateien Sollen andere Dateiformate eingelesen werden, werden unterschiedliche Packages benötigt. 7.3.2.1 Haven Package Abb. 7.2: haven Package Logo Das haven-Package ist ein mächtiges Package, um Dateien in anderen gängigen Statistik-Formaten (.sav, .dta) einzulesen. Die Funktionen funktionieren weitestgehend selbsterklärend: needs(haven) df_example_spss &lt;- read_spss(file = &quot;data/example.sav&quot;, # Dateipfad encoding = &quot;UTF-8&quot;) # Optional df_example_stata &lt;- read_stata(file = &quot;data/example.dta&quot;, # Dateipfad encoding = &quot;UTF-8&quot;) # Optional "],["tidyverse.html", "Kapitel 8 Tidyverse 8.1 Das “Tidyverse” 8.2 dplyr:: 8.3 Variablen Manipulieren 8.4 Fälle Manipulieren 8.5 Prüfe dich selbst", " Kapitel 8 Tidyverse In diesem Kapitel wollen wir uns damit auseinandersetzen, was das Tidyverse ist und was für Funktionen die einzelnen Packages des Tidyverse uns bereitstellen. Einen besonderen Fokus wollen wir vor allem erstmal auf die Datenverarbeitung legen, die diese im Regelfall auch die meiste Zeit beansprucht. 8.1 Das “Tidyverse” Das Tidyverse ist eine Sammlung von Packages, welche einer gemeinsamen Grammatik folgen. Im Folgenden wird ein Package immer durch die doppelten Punkte gekennzeichnet sein, zum Beispiel: dplyr::. Das entspricht in R der Syntax, um eine Funktion aus einem bestimmten Package-Scope abzurufen. So können zwei Funktionen zwar den gleichen Namen haben, aber unterschiedlich implementiert sein, wie etwa dplyr::filter() und stats::filter(), welche in eurem Skript uneindeutig einfach nur filter() heißen könnten. Bei solchen Konflikten, ist es ratsam des jeweilige Package, aus welchem man die Funktion aufrufen will explizit zu deklarieren, also samt dplyr::. Abb. 8.1: Tidyverse Components Logo Die Logos der wichtigsten Packages könnt ihr in der Abbildung sehen. Wir werden immer wieder auf einige von diesen zurückkommen und lernen, diese nach und nach anzuwenden. 8.1.1 Tidyverse laden Das Tidyverse ladet ihr wie jedes andere Package auch, also zum Beispiel mit library() oder needs(). Im Prinzip ladet ihr dabei aber gleich mehrere verschiedene Packages, welche ihr dann nicht im Einzelnen nochmal nachladen müsst. library(tidyverse) Die geladenen Packages werden hier mit der geladenen Version gelistet, sowie auch potenzielle Konflikte. 8.2 dplyr:: In dieser Sitzung werden wir uns vornehmlich mit dem Package dplyr:: beschäftigen. Auf dem entsprechenden Cheatsheet findet ihr alle Funktionen übersichtlich dargestellt, welche wir jetzt im Detail besprechen wollen. Abb. 8.2: dplyr Logo Hinweis: Das Packet dplyr:: erwartet, dass ihr sogenannte “tidy data” vorliegen habt. Das bedeutet, dass jede Spalte eine Variable und jede Zeile eine Beobachtung/Fall ist (Vergleich auch Cheatsheet oben links). Wie ihr in der Übung sehen werdet, muss das nicht immer der Fall sein und ihr müsst, wenn eure Daten nicht “tidy” sind, diese dann erst entsprechenden anpassen. Dazu gibt es das Package tidyr::. 8.2.1 Daten verfügbar machen Das Package dplyr:: ist nicht nur eine Sammlung von verschiedenen Funktionen, sondern beinhaltet auch Datensätze in seinem “Scope”. Wenn ihr das Paket geladen habt, könnt ihr auf diese Datensätze zugreifen. Wir wollen für die folgenden Demonstrationen den Datensatz starwars aus dplyr:: verwenden, welcher verschiedene Merkmale von Star Wars Charakteren umfasst. Über den Zuweisungsoperator können wir den Datensatz auch global verfügbar machen, indem wir ihn an den Namen starwars binden. starwars &lt;- dplyr::starwars starwars ## # A tibble: 87 × 14 ## name height mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skyw… 172 77 blond fair blue 19 male mascu… ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… ## 3 R2-D2 96 32 &lt;NA&gt; white,… red 33 none mascu… ## 4 Darth Vad… 202 136 none white yellow 41.9 male mascu… ## 5 Leia Orga… 150 49 brown light brown 19 fema… femin… ## 6 Owen Lars 178 120 brown,… light blue 52 male mascu… ## 7 Beru Whit… 165 75 brown light blue 47 fema… femin… ## 8 R5-D4 97 32 &lt;NA&gt; white,… red NA none mascu… ## 9 Biggs Dar… 183 84 black light brown 24 male mascu… ## 10 Obi-Wan K… 182 77 auburn… fair blue-g… 57 male mascu… ## # … with 77 more rows, 5 more variables: homeworld &lt;chr&gt;, ## # species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, ## # and abbreviated variable names ¹​hair_color, ²​skin_color, ## # ³​eye_color, ⁴​birth_year 8.3 Variablen Manipulieren Die Variablen starwars$films, starwars$vehicles und starwars$starships sind allesamt Listen. Diese sollen heute nicht unser Thema sein, deshalb können wir sie gleich entfernen. Eine base:: R Möglichkeit dazu wäre: starwars[ ,c(&quot;films&quot;, &quot;vehicles&quot;, &quot;starships&quot;)] &lt;- NULL Hierbei verwenden wir den besonderen Datentyp NULL, welcher “nichts” symbolisiert (Gar nicht so einfach “nichts” zu benennen). Indem wir die einzelnen Variablen auf NULL setzen, entfernen wir sie aus unserem Datensatz. Allerdings bringt diese Variante einige Probleme mit sich: schwer zu lesen (Syntaktisch) ungewünschte Objektmanipulation (Kann nicht rückgängig gemacht werden) Eine weitere Möglichkeit unter Verwendung von base:: R Funktionen wäre: starwars |&gt; subset(select = -c(films, vehicles, starships)) |&gt; dim() ## [1] 87 11 Schon sehr viel besser! Allerdings könnte man auf hohem Niveau noch folgende Kritik anbringen: subset() kennt keine klare Trennung von Fällen und Variablen (Deswegen müssen wir hier das Argument select = explizit angeben) nur bedingt partiell ausführbar (Wir übergeben einen Vektor mit Objekten und nicht deren Namen) Anmerkung: Im Folgenden wird immer wieder die Funktion dim() die Pipes (%&gt;%) abschließen. Das dient dazu, die Veränderung zu demonstrieren, ohne den ganzen Dataframe ausgeben zu müssen. Jetzt noch die dplyr:: Variante: starwars %&gt;% select(!c(&quot;films&quot;,&quot;vehicles&quot;,&quot;starships&quot;)) %&gt;% dim() ## [1] 87 11 Anmerkung: Im Prinzip könnt ihr in fast jedem Fall die native Pipe und die Tidyverse Pipe synonym zueinander benutzen. Die wechselnde Veränderung in den Codebeispielen soll andeuten, ob wir gerade mit Tidyverse Funktionen arbeiten oder nicht. Die dplyr:: Variante sieht zwar sehr ähnlich zum letzten Beispiel aus, ist im Detail aber doch anders. Zum Beispiel haben wir eine extra Funktion select() und nicht mehr nur ein Argument einer Funktion subset(select = ...). Also bleiben wir doch voerst dabei! In den Beispielen haben wir jetzt Variablen entfernt, indem wir die Negation entweder über das - oder das logische Symbol ! vor unseren Vektor gesetzt haben. Natürlich können wir dply::select() auch dazu nutzen, um bestimmte Variablen aus einem Dataframe explizit auszuwählen: starwars %&gt;% select(&quot;height&quot;, &quot;eye_color&quot;) %&gt;% dim() ## [1] 87 2 8.3.1 Neue Variablen erstellen Mit der Funktion dplyr::mutate() können wir neue Variablen erstellen und diese zu unserem Tibble (Dataframe) hinzufügen. Dazu können wir auch bereits existierende Variablen nutzen, was extrem eleganten Code ermöglicht! starwars %&gt;% mutate(height_in_meters = height / 100, # Höhe in Meter umrechnen index = 1:n() # fortlaufende Nummer ) %&gt;% dim() ## [1] 87 16 Die Funktion mutate() fügt immer eine neue Variable zu unserem Dataframe hinzu. Alle anderen Variablen bleiben also erhalten. Im Beispiel oben haben wir zum Beispiel zwei Variablen hinzugefügt height_in_meters und index und haben jetzt 16 statt den ursprünglich 14 Variablen. Im Gegensatz dazu entfernt die Funktion transmute() alle Variablen, die nicht explizit als Argumente angegeben werden. Das ist unter anderem hilfreich, wenn wir einen großen externen Datensatz auf für uns relevante Variablen reduzieren wollen und diese zugleich transformieren wollen. 8.3.2 Variablen umbennen Mit der Funktion dplyr::rename() können wir ganz einfach die Variablen umbenennen, diesem Schema folgend: starwars %&gt;% rename(neuer_name = alter_name, ...) Am Beispiel könnte das dann so aussehen: starwars %&gt;% rename(&quot;height_in_cm&quot; = &quot;height&quot;, &quot;mass_in_kg&quot; = &quot;mass&quot;) %&gt;% names() # Gibt die Namen aller Variablen aus ## [1] &quot;name&quot; &quot;height_in_cm&quot; &quot;mass_in_kg&quot; &quot;hair_color&quot; ## [5] &quot;skin_color&quot; &quot;eye_color&quot; &quot;birth_year&quot; &quot;sex&quot; ## [9] &quot;gender&quot; &quot;homeworld&quot; &quot;species&quot; &quot;films&quot; ## [13] &quot;vehicles&quot; &quot;starships&quot; Wie man sehen kann, wurden die Namen \"height\" und \"mass\" in die von uns angegebenen neuen Namen geändert. 8.4 Fälle Manipulieren Der Ausgangsdatensatz hat 87 Fälle. Als Nächstes wollen wir diese Fälle nach gewissen Kriterien filtern. Wenn wir zum Beispiel nur Charaktere mit weißen Haaren betrachten wollten, könnten wir die dplyr::filter() Funktion folgendermaßen verwenden: starwars %&gt;% filter(hair_color == &quot;white&quot;) ## # A tibble: 4 × 14 ## name height mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Yoda 66 17 white green brown 896 male mascu… ## 2 Ki-Adi-Mun… 198 82 white pale yellow 92 male mascu… ## 3 Dooku 193 80 white fair brown 102 male mascu… ## 4 Jocasta Nu 167 NA white fair blue NA fema… femin… ## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated ## # variable names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year Wie auch in anderen Funktionen, die wir bereits kennengelernt haben, können wir auch logische Konjunktoren verwenden, um bestimmte Bedingungen auszudrücken: starwars %&gt;% filter(homeworld == &quot;Tatooine&quot; &amp; sex != &quot;male&quot;) ## # A tibble: 4 × 14 ## name height mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… ## 2 Beru White… 165 75 brown light blue 47 fema… femin… ## 3 R5-D4 97 32 &lt;NA&gt; white,… red NA none mascu… ## 4 Shmi Skywa… 163 NA black fair brown 72 fema… femin… ## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated ## # variable names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year Hier zum Beispiel erhalten wir einen Dataframe, der nur die Fälle beinhaltet, welche aus Tatooine stammen und nicht männlich sind. Achtung! filter() behält nur diejenigen Zeilen (Fälle), über welche definitiv gesagt werden kann, dass sie der angegebenen Bedingung entsprechen und somit “wahr” sind. Alle NA-Werte, für welche wir nicht wissen, ob sie wahr wären, werden nicht mit aufgenommen! 8.4.1 Fälle Gruppieren Am wohl unscheinbarsten ist die Funktion group_by(), da sie unseren Datensatz oberflächlich betrachtet gar nicht verändert. starwars %&gt;% group_by(homeworld) %&gt;% head(5) # nimm die ersten fünf Fälle ## # A tibble: 5 × 14 ## # Groups: homeworld [3] ## name height mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex gender ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Luke Skywa… 172 77 blond fair blue 19 male mascu… ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 none mascu… ## 3 R2-D2 96 32 &lt;NA&gt; white,… red 33 none mascu… ## 4 Darth Vader 202 136 none white yellow 41.9 male mascu… ## 5 Leia Organa 150 49 brown light brown 19 fema… femin… ## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, ## # films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;, and abbreviated ## # variable names ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year Im Hintergrund haben wir unseren Tibble aber um das Attribut group ergänzt, welches jeweils die Zeilennummern für die Fälle einer Gruppe als integer Vektor speichert. starwars %&gt;% group_by(homeworld) %&gt;% attr(&quot;group&quot;) %&gt;% head(5) ## # A tibble: 5 × 2 ## homeworld .rows ## &lt;chr&gt; &lt;list&lt;int&gt;&gt; ## 1 Alderaan [3] ## 2 Aleen Minor [1] ## 3 Bespin [1] ## 4 Bestine IV [1] ## 5 Cato Neimoidia [1] Durch das nun zu unserem Datensatz beigefügte Attribut verhalten sich folgende Tidyverse Funktionen teilweise anders. Dies ermöglicht es uns, für die einzelnen Gruppen aggregierte Kennzahlen zu ermitteln: starwars %&gt;% group_by(homeworld) %&gt;% # gruppiere nach homeworld summarise(avg_height = mean(height, na.rm = TRUE), n = n()) %&gt;% arrange(desc(n)) %&gt;% # absteigend sortiert nach Anzahl head(3) # nimm die ersten drei Fälle ## # A tibble: 3 × 3 ## homeworld avg_height n ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Naboo 175. 11 ## 2 Tatooine 170. 10 ## 3 &lt;NA&gt; 139. 10 Die hier verwendete Funktion summarise() oder summarize() macht es uns nun möglich, Gruppeneigenschaften zu ermitteln. Analog zu mutate() können wir so Spalten zu dem resultierenden Dataframe hinzufügen. Auf dem dplyr:: Cheatsheet findet ihr auf der zweiten Seite unter “Summary Functions” ein paar Funktionen, welche ihr auf die jeweiligen Gruppen anwenden könnt. Im Beispiel haben wir mean() benutzt, um das durchschnittliche Gewicht der Gruppe zu ermitteln; n() hingegen gibt die Anzahl an Fällen in der Gruppe aus. Zu beachten gilt es, dass alle unbestimmten Werte (NA) zu einer Gruppe zusammengefasst wurden. Mit ungroup() kann das Gruppenattribut wieder entfernet werden. Man sollte sich immer vergegenwärtigen, an welchem Punkt man Analysen auf Gruppenebene oder auf Individualebene macht, bzw. ob man mit einem gruppierten Tibble arbeitet oder nicht. 8.5 Prüfe dich selbst Von dieser Sitzung solltest du Folgendes mitgenommen haben: Du solltest wissen, was das Tidyverse ist. Du solltest wissen, was “tidy-data” auszeichnet (siehe 8.2). Du solltest unterscheiden können, mit welchen Funktionen man Fälle und mit welchen man Variablen manipuliert. Du solltest verstanden haben, was die Funktion group_by() macht und wann diese nützlich sein könnte. "],["kontrollstrukturen.html", "Kapitel 9 Kontrollstrukturen 9.1 Prinzipien der Programmierung 9.2 Funktionen selber schreiben 9.3 Kontrollstrukturen 9.4 Schleifen 9.5 Vektorisiertes Programmieren 9.6 Prüfe dich selbst", " Kapitel 9 Kontrollstrukturen In diesem Kapitel sollen einige Prinzipien der Programmierung vorgestellt werden und gezeigt werden, wie sich diese in R umsetzen lassen. R bietet dabei eine Vielzahl an Möglichkeiten, von welchen einige besprochen werden sollen. 9.1 Prinzipien der Programmierung R setzt in großen Teilen die Ideen der funktionalen Programmierung um. Das bedeutet für uns vor allem erst mal, dass ein Großteil der Problemlösung über Funktionen erfolgt. Folgende Prinzipien gilt es zu verinnerlichen, wenn man diese Eigenschaft effizient ausnutzen will: DRY-Prinzip: “Don’t repeat yourself”. Treten wiederholt gleiche oder ähnliche Code-Elemente auf, so sollte man diese als Funktion zusammenfassen. “Divide and Conquer”- Prinzip: Oft ist es besser, das Problem oder die Analyse in verschieden Teilprobleme aufzuteilen und für diese entsprechende Funktionen zu schreiben. “Abstraktion”/Blackbox-Prinzip: Anstelle explizit viele Codezeilen im Hauptcode zu listen, welche letztlich gemeinsam eine bestimmte Funktion erfüllen, ist es besser, diese Komplexität in einer Funktion zu “verstecken”. Black Box: Entscheidend ist was die Funktion macht und nicht wie sie es macht. Welche Möglichkeiten es gibt, diesen Prinzipien nachzukommen, wollen wir uns jetzt anschauen. 9.2 Funktionen selber schreiben Funktionen waren schon oft unser Thema. Jetzt wollen wir uns anschauen, wie man selbst eine Funktion schreiben kann. Dies geschieht im Allgemeinen über dieses generelle Schema einer Funktionszuweisung: name_function &lt;- function(arg1, ...) {body} Mit der Funktion function() können wir Funktionen erzeugen. :) Man beachte allerdings, dass nach den Klammern () noch etwas folgt. Funktionen sind auch Objekte und können wie alle anderen Objekte auch an Namen gebunden werden. Eine Funktion hat typischerweise Argumentstellen (arg1, ...), welche als sogenannte Funktionsparameter an den body weitergegeben werden. Der body oder auch Rumpf der Funktion enthält den Code, welcher beim Funktionsaufruf ausgeführt werden soll. Eine konkrete Funktionszuweisung könnte dann so aussehen: quadrat &lt;- function (x) {x^2} quadrat(2) ## [1] 4 Die erzeugte Funktion nimmt eine Zahl x als Parameter entgegen und berechnet das Quadrat dieser. Da im body nichts Abweichendes definiert ist, wird das letzte Objekt zurückgegeben, also das Ergebnis unserer Berechnung. Unser Rückgabewert entspricht also dem Ergebnis der funktion x^2. Optional kann man eine Rückgabe innerhalb des Rumpfes der Funktion auch erzwingen. Dazu verwendet man die Funktion return(). Zu beachten gilt es, dass die Ausführung der Funktion beim ersten Aufruf der return() Funktion abbricht und folgender Code nicht mehr berücksichtigt wird. quadrat &lt;- function (x) { y &lt;- x^2 return(y) y &lt;- y + 1 return(y) } quadrat(2) ## [1] 4 Im gegebenen Beispiel wird alles nach dem ersten return(y) nicht mehr ausgeführt. Der Rückgabewert der Funktion entspricht dem Wert des Objektes, welches mit dem Namen y verknüpft ist. Wie wir gerade schon gesehen haben, können wir auch innerhalb von Funktionen Objekte an Namen binden. Dabei gilt es aber zu berücksichtigen, dass wir dabei kein Objekt in unserem Global Environment anlegen. Die Zuweisung gilt lediglich für den jeweiligen Wirkungsbereich (Scope) der Funktion, also alles, was in den geschweiften Klammern {...} steht. x &lt;- 2 quadrat &lt;- function (x) { x &lt;- x^2 return(x) } quadrat(x) ## [1] 4 x ## [1] 2 Wie wir hier sehen können, bleibt die globale Zuweisung für den Namen x erhalten, trotz der erneuten Zuweisung eines Namens x innerhalb der Funktion. Anmerkung: Um den “Fluss” eurer Funktion nachzuverfolgen, könnt ihr euch Nachrichten auf der Konsole im Funktionsablauf ausgeben lassen. Das ist vor allem praktisch, wenn ihr euch nicht sicher seid, welchen Werte welches Objekt zu welchem Zeitpunkt hat. x &lt;- 2 quadrat &lt;- function(x) { message(&quot;Funktion beginnt mir ihrer Arbeit, x ist: &quot;, x) x &lt;- x^2 message(&quot;Erste Berechnung erfolgreich, x ist: &quot;, x) x } quadrat(x) ## Funktion beginnt mir ihrer Arbeit, x ist: 2 ## Erste Berechnung erfolgreich, x ist: 4 ## [1] 4 Alternativ könnt ihr eurer Variablen x einen konstanten Wert zuweisen, zum Beispiel x &lt;- 2, und den {body} der Funktion Schritt für Schritt ausführen. Wenn man einen sogenannten Default-Wert hinterlegt, dann kann eure Funktion auch ohne eine Belegung der entsprechenden Argumentstelle aufgerufen werden: quadrat &lt;- function (x = 10) { x^2 } quadrat(2) ## [1] 4 quadrat() ## [1] 100 Defaults können sehr nützlich sein, um Komplexität zu verstecken. Seit R 4.1.0 gibt es in R einen Shortcut um anonyme Funktionen zu deklarieren: pow &lt;- \\(x, y = 2) x^y pow(2,3) ## [1] 8 Statt function schreibt man einfach \\ und die Klammern des Rumpfes {} werden einfach weggelassen. Das ist vor allem dann sinnvoll, wenn man eine Funktion ad hoc deklarieren will, zum Beispiel als Argument einer anderen Funktion. Darauf kommen wir später noch einmal zurück. Allerdings kann diese verkürzte Schreibweise auch zur schlechteren Lesbarkeit eures Codes führen. 9.3 Kontrollstrukturen Kontrollstrukturen dienen der Ablaufsteuerung und sind essenziell für die Konstruktion von Algorithmen: Folgende Logiken können dabei implementiert werden: Verzweigungen/Fallunterscheidungen: Falls heute die Sonne scheint, geh in den Park. Falls nicht, dann lerne für die nächste Klausur. Schleifen: Solange die Sonne scheint, bleibe im Park. Bestimme alle Quadratzahlen von \\(1^2\\) bis \\(100^2\\). Ein klassische Fallunterscheidung können wir in R mit einer if-else Abfolge umsetzen: x &lt;- 1 if (x &gt; 0) { print(paste(x, &quot;ist positiv&quot;)) } else { print(paste(x, &quot;ist nicht-positiv&quot;)) } ## [1] &quot;1 ist positiv&quot; Wir setzen hier zunächst x als 1. Danach kommt die logische Abfrage, welche entweder TRUE oder FALSE sein muss. Ist das Ergebnis TRUE, dann wird der Code in den ersten geschweiften Klammern {print(paste(x, \"ist positiv\"))} ausgeführt und die Auswertung bricht ab. Falls das Ergebnis FALSE ist, wird der Code in den ersten geschweiften Klammern übersprungen und der else Fall wird ausgeführt. Alternativ können wir if-else auch ohne geschweift Klammern schreiben: x &lt;- 1 if (x &gt; 0) print(paste(x, &quot;ist positiv&quot;)) else print(paste(x, &quot;ist nicht-positiv&quot;)) ## [1] &quot;1 ist positiv&quot; Hierbei gilt es allerdings zu beachten, dass, wenn wir nur die erste Zeile (if (x &gt; 0)) ausführen, der restliche Code erst mal nicht berücksichtigt wird. Wir erhalten eine partiell ausgeführte Funktion zurück, welche noch weitere Eingaben erwartet. Führen wir die folgenden beiden Zeilen aus, kommen wir zum selben Ergebnis. Was zunächst umständlich erscheint, ist im body einer Funktion kein Problem, da dieser sowieso von oben nach unten durchläuft. Ein Beispiel für eine Funktion mit Fallunterscheidung könnte so aussehen: is.positive &lt;- function(x) { if (x &gt; 0) { return(TRUE) } else { return(FALSE) } } is.positive(-1.1) ## [1] FALSE is.positive(11) ## [1] TRUE Es mal ohne geschweifte Klammern umzuschreiben wäre eine gute Übung! 9.3.1 Vektorisierte Fallunterscheidungen Wollen wir if-else auf einen Vektor anwenden und erwarten einen Vektor als Ergebnis, müssen wir keine eigene Funktion schreiben. Es existieren bereits vektorisierte if-else Funktionen, zum Beispiel aus dem Package dplyr::: library(dplyr) x &lt;- c(1991, 2004, 1988) if_else(condition = x &gt;= 1981 &amp; x &lt;= 1996, true = &quot;Millennial&quot;, false = &quot;kein Millennial&quot;) ## [1] &quot;Millennial&quot; &quot;kein Millennial&quot; &quot;Millennial&quot; Wenn ihr mehr als zwei Fälle (TRUE und FALSE) unterscheiden wollt, bietet sich die ebenfalls vektorisierte dplyr::case_when() Funktion an. Eine Beispielanwendung dafür könnte die Kategorisierung einer stetigen Variable sein: starwars %&gt;% select(name, birth_year) %&gt;% mutate( age_categorized = case_when( birth_year &gt; 200 ~ &quot;stone_old&quot;, birth_year &lt;= 200 &amp; birth_year &gt; 100 ~ &quot;old&quot;, birth_year &lt;= 100 &amp; birth_year &gt; 20 ~ &quot;mid_aged&quot;, birth_year &lt;= 20 ~ &quot;young&quot;, TRUE ~ &quot;other&quot; # catch them all ) ) ## # A tibble: 87 × 3 ## name birth_year age_categorized ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Luke Skywalker 19 young ## 2 C-3PO 112 old ## 3 R2-D2 33 mid_aged ## 4 Darth Vader 41.9 mid_aged ## 5 Leia Organa 19 young ## 6 Owen Lars 52 mid_aged ## 7 Beru Whitesun lars 47 mid_aged ## 8 R5-D4 NA other ## 9 Biggs Darklighter 24 mid_aged ## 10 Obi-Wan Kenobi 57 mid_aged ## # … with 77 more rows Anmerkung: Falls euch dieses Zeichen unbekannt vorkommt: %&gt;% dann schaut doch noch mal in das Kapitel 5, dort haben wir Pipes mit der analogen base-R Notation (|&gt;) eingeführt. Im Beispiel wird eine neue Spalte age_categorized angelegt, welche eine Kategorisierung des Geburtsalters darstellt. Die einzelnen Fälle, welche in case_when() beschrieben werden, sind dabei jeweils durch ein Komma , getrennt. Vor der Tilde ~ kommt immer die Bedingung. Dahinter steht, was in diesem Fall passieren soll. Die letzte Bedingung TRUE ist immer wahr und greift dann, wenn alle vorherigen Bedingungen zu FALSE evaluiert worden sind. In unserem Beispiel fallen darunter alle NA-Werte. Die Rückgabe ist ein character-Vektor derselben Länge wie der von der Variable birth_year. 9.4 Schleifen Schleifen (Loops) dienen dem wiederholten Ausführen eines Anweisungsblocks (loop body). Es gibt sie in verschiedenen Varianten: for (i in I) {Anweisung} Interpretation: Wiederhole Ausdruck für jeden Indexwert i in der Indexmenge I. while (Bedingung) {Anweisung} Intepretation: Wiederhole Anweisung, solange Bedingung erfüllt ist. repeat {Anweisung} Interpretation: Wiederhole die Anweisung. Anmerkung: Zusätzlich lassen sich diese Loops steuern mit next (springt zur nächsten Iteration) und break (bricht die Schleife ab). Wir werden uns hier nur noch der wohl gängigsten Methode, nämlich des for-loops, widmen. Schauen wir uns zunächst das einfachste Beispiel für einen for-loop an: for (i in 1:10){ print(i) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 Der for-loop iteriert über einen Vektor mit den Zahlen 1 bis 10 und führt den Code in den geschweiften Klammern in jeder Iteration aus. Der Index i wird nach jedem Schleifendurchlauf um eine Position inkrementiert. Mit diesem Wissen können wir nun einen for-loop schreiben, welcher über die Werte eines Vektors iteriert und jeweils den Wert der i’ten Position im Quadrat in einen neuen Vektor schreibt. v1 &lt;- 1:10 v2 &lt;- numeric(length = 10) # leeren Vektor anlegen for (i in 1:10){ v2[i] &lt;- sqrt(v1[i]) } v2 ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 ## [8] 2.828427 3.000000 3.162278 Da die meisten Funktionen in R bereits vektorisiert sind (sqrt(v1)) ist ein for-loop nicht immer die beste Variante, manchmal kann er allerdings sehr hilfreich sein. 9.5 Vektorisiertes Programmieren Vektorisiertes Programmieren bedeutet, dass wir Operationen auf einem Vektor ausführen und dementsprechenden einen Vektor zurückbekommen. Dabei wird eine Funktion auf jedes Element eines Vektors angewandt, was auch eine Möglichkeit ist, iterative Probleme zu lösen. Im letzten Teil wollen wir uns jetzt noch die purrr::map() Funktionsfamilie anschauen, welche vektorbasiert funktioniert. Alternativ dazu gibt es im base-R die lapply() Funktionsfamilie, welche eine ähnliche Intention verfolgt, die wir uns aber nicht mehr anschauen werden können. Die Aufgabe, welche wir gerade mit einem for-loop gelöst haben, kann man alternativ auch vektorbasiert mit map() lösen: library(purrr) v1 &lt;- 1:10 map_dbl(.x = v1, .f = sqrt) ## [1] 1.000000 1.414214 1.732051 2.000000 2.236068 2.449490 2.645751 ## [8] 2.828427 3.000000 3.162278 Dabei passiert Folgendes (fun steht für function): Abb. 9.1: Quelle: https://tutorials.shinyapps.io/map-intro/_w_543ccdaf/www/images/map.png Generell sind die map() Funktionen nach diesem Schema aufgebaut: map_rueckgabetyp(liste, funktion) Wichtig!: Wenn wir eine Funktion als Objekt übergeben, setzen wir keine Klammern. Der Rückgabetyp, welchen wir oben im Beispiel verwendet haben, war dbl, was einer Fließkommazahl, also im Prinzip numeric entspricht. Als erstes Argument übergibt man eine Liste oder besser gesagt einen Vektor. Die Liste ist eigentlich nur ein Sonderfall von verschachtelten Vektoren, weshalb wir auch einen Vektor übergeben können. Richtig nützlich wird map() aber erst, wenn man es mit Listen zu tun hat. Das zweite Argument ist eine Funktion, welche über ihren Namen als an map() übergeben wird. Benutzen wir die map() Funktion ohne Rückgabetyp, bekommen wir immer eine Liste zurück: map(1:10, log) %&gt;% head(3) ## [[1]] ## [1] 0 ## ## [[2]] ## [1] 0.6931472 ## ## [[3]] ## [1] 1.098612 Was für Funktionen es alles gibt, ist unter anderem auf dem Cheatsheet zu purrr:: sehr übersichtlich dargestellt. Es ist auch möglich, der map() übergebenen Funktion noch weitere Argumente zu übergeben. Diese werden map() einfach als weitere Argumente übergeben: v1_log &lt;- map_dbl(v1, log) map_dbl(.x = v1_log, .f = round, digits = 2) ## [1] 0.00 0.69 1.10 1.39 1.61 1.79 1.95 2.08 2.20 2.30 Über sogenannte anonyme Funktionen (welche keinen Namen haben), können wir gleich in der Argumentstelle von map(), welche die Funktion entgegennimmt, eigene Funktionen schreiben. Beispiel: map_dbl(v1, ~ log(.x) %&gt;% round(2)) ## [1] 0.00 0.69 1.10 1.39 1.61 1.79 1.95 2.08 2.20 2.30 Die Tilde (~) zeigt dabei an, dass eine Funktion folgt. Mit .x kann man das aktuelle Listenelement ansprechen. Ausgeschrieben könnte die Funktion so ausschauen: un_lambda &lt;- function (x) { round(log(x), 2) } Natürlich könnt ihr die Funktionen auch erst schreiben und dann nur noch über den Namen map() als Argument weiter reichen. Dem Beispiel folgend: map_dbl(v1, un_lambda) ## [1] 0.00 0.69 1.10 1.39 1.61 1.79 1.95 2.08 2.20 2.30 Bei diesem Vorgehen empfiehlt es sich, einen aussagekräftigeren Namen für die Funktion zu wählen, welcher auch andeutet, was die Funktion macht. 9.6 Prüfe dich selbst Von dieser Sitzung solltest du olgendes mitgenommen haben: Du solltest Funktionen in R selber schreiben können. Du solltest Kontrollstrukturen dazu nutzen können, eigene Probleme zu lösen. Du solltest mindestens zwei Möglichkeiten nennen können, wie man in R iterative Probleme lösen kann. Du solltest verstanden haben, wie vektorisierte Funktionen ausgewertet werden. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
