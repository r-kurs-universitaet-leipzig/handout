<<<<<<< HEAD
[["index.html", "Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Chapter 1 Einführung 1.1 Was ist R und warum sollte man R lernen? 1.2 Installation", " Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Peter Kannewitz &amp; Peer Schwertfeger Stand: 2022-04-02 Chapter 1 Einführung Dieses Handout ist Teil des Grundkurses in R am URZ und am Academic Lab der Uni Leipzig. Dieses Dokument ist in ständiger Bearbeitung und kann sich daher regelmäßig Ändern. Besonderem Dank gilt Stephan Poppe für die Unterstützung beim Erstellen der Materialien für diesen Kurs. 1.1 Was ist R und warum sollte man R lernen? R ist eine freie Programmiersprache, die in erster Linie für statistische Analysen konzipiert wurde. Durch ihre große Community (siehe Stack Overflow oder RBlogger) und ihre ständige Weiterentwicklung durch sogenannte Packages, ist der Funktionsumfang von R praktisch unbegrenzt. Neben den klassischen Funktionen statistischer Software (Datenaufbereitung, Analysen, Graphikerstellung) sind z.B. folgende Anwendungen möglich: Erstellen von Präsentationen und Papern (mit RMarkdown) Webscraping Qualitative Textanalyse Auslesen von Datenbanken Automatisierungen uvm. Zum Teil durch die vielfältigen Anwendungsmöglichkeiten hat sich bzw. entwickelt sich R zum Goldstandard in der akademischen Welt und in vielen Bereichen der Wirtschaft1. Wie auch bei Sprachen, lernt man Programmiersprachen nicht (nur) durch Kurse. Eine Aktive Auseinandersetzung mit konkreten Problemen hilft, “fließender” im Umgang mit der Sprache zu werden. Kommt man einmal nicht weiter (wird passieren… versprochen!), hilft es, sich solange mit dem Thema zu beschäftigen, bis eine Lösung gefunden wurde. Warum sollte man das auf sich nehmen? 6 Gründe, R zu lernen: Open Source und plattformübergreifend Praktisch unbegrenzter Funktionsumfang Entwickelt sich zum Standard in akademischer Welt und in der Wirtschaft Publizierfähige Graphiken Integration von Aufbereitung, Analyse und Präsentation Internationale Community (, etc.) 1.2 Installation Zunächst muss unser Computer R “lernen”. Um R zu installieren, gehe auf die entsprechende . Wähle dein Betriebssystem aus und folge den Anweisungen auf der Website. Um produktiv zu arbeiten, sollte zusätzlich die open source-Vesion von RStudio installiert werden. Weitere Infos hierzu gibt es . https://analyticsindiamag.com/has-python-completely-edged-out-r-in-data-science-field/↩︎ "],["oberfläche.html", "Chapter 2 Oberfläche 2.1 R GUI 2.2 RStudio", " Chapter 2 Oberfläche 2.1 R GUI Mit der Installation von R wird gleichzeitig ein Graphical User Interface (GUI) mitinstalliert. Hier können wir bereits R Code eingeben und mit Enter an den Computer übergeben. In der nächsten Zeile wird die Antwort vom Computer an uns zurückgegeben. Diese Oberfläche ist jedoch wenig “komfortabel”. Sie bietet keine zusätzlichen Editoren oder Fenster, um z.B. die gespeicherten Objekte oder Graphiken anzuzeigen. 2.2 RStudio RStudio bietet eine nutzer:innenfreundliche (und freie) Alternative für die Nutzung von R. Hier sind zusätzliche Editoren und Übersichten enthalten. Zu nennen ist beispielsweise: Script-Editor Übersicht über Objekte in globaler Umgebung Übersicht über Packages Einfache Dateienhandhabung durch Projects u.v.m. Das Interface von RStudio besteht aus mehreren Fenstern. 2.2.1 Console Die R Console dient zur direkten Übergabe von Ausdrücken bzw. Funktionen an R und ist identisch mit der Anzeige in der R GUI. Diese eignet sich für für kleine Tasks bzw. Tests. Das Ergebnis wird direkt unterhalb des Befehls angezeigt. Außerderm werden Ergebnisse aus den Scripten, die keine Graphiken sind, hier angezeigt. Nachdem Code hier eingetippt wurde, wird die Befehlszeile mit der Taste ENTER ausgeführt. 2.2.2 Script Editor In der Console kann euer Code langfristig nicht gespeichert werden. Sogenannte R Scripte ermöglichen euch, euren Code zu speichern und nacheinander auszuführen. Der entsprechende Editor muss zunächst händisch geöffnet werden: File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script Nachdem Code geschrieben wurde, kann der Code mit folgender Tastenkombination ausgeführt werden: strg + ENTER (Win) bzw. command + ENTER (Mac) Hierzu genügt es, wenn sich der Cursor in einer der Zeilen der Befehlssequenz befindet. Sollen mehrere Befehlssequenzen ausgeführt werden, müssen diese vorher markiert werden. Mit # lassen sich Kommentare in das Script schreiben. Zeilen, in denen dieses Zeichen steht, werden von R ignoriert und nicht ausgeführt. "],["atomare-datentypen.html", "Chapter 3 Atomare Datentypen 3.1 Arithmetische Grundoperationen und Basisfunktionen 3.2 Erzeugung von referenzierbaren Objekten 3.3 Logische Werte und Operationen 3.4 Zeichenketten (character strings) 3.5 Klasse eines Datenobjektes 3.6 Spezielle Werte 3.7 Prüfe dich selbst", " Chapter 3 Atomare Datentypen Datentypen sind die Grundlage einer jeder Programmiersprache und somit essenziell zum Verständnis dieser. Sie dienen dazu, verschiedene Typen unterscheiden. Etwa Zahlen von Buchstaben. Das ist besonders wichtig, da wir mit unterschiedlichen ‘Typen’ unterschiedliche Operationen ausführen, bzw. nicht ausführen, können. Zum Beispiel können wir mit Zahlen rechnen, mit Buchstaben hingegen nicht. Mit logischen Bedingungen können wir wiederum Wahrheitswerte ermitteln, mit Zahlen hingegen nicht. Zu wissen, welche Eigenschaften die verschiedene Datentypen haben und welche Operationen mit diesen möglich sind, hilft dabei vielen potenziellen Fehlern vorzubeugen und so Frustration zu vermeiden. Zunächst einmal wollen wir uns die atomaren Datentypen anschauen. Diese bilden die Grundlage aller folgenden Datentypen. Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichenfolge “Mexico” NA,NULL,NaN Unbestimmt, Leer, Undefiniert Inf Unendlich Die numerischen Datentypen integer und numeric erlauben es uns numerische Informationen zu repräsentieren. Mit dem Datentyp logic können wir logische Informationen repräsentieren. Um symbolische Informationen zu repräsentieren, verwenden wir den Datentyp character. Mit numerischen-, logischen- und symbolischen Informationen ist es bereits möglich eine Vielzahl von Sachverhalten auszudrücken. Was dies sein kann, wollen wir uns im Folgenden anschauen. 3.1 Arithmetische Grundoperationen und Basisfunktionen R beherscht für alle Zahlen die arithmetischen Grundoperationen und eignet sich somit wunderbar als Taschenrechner. Operation Beschreibung Beispiel +,- Addition, Subtraktion 3-1.2 *,/ Multiplikation, Division 4.8/4 ^ Potenz 5^2 Beispiel: 1+2 ## [1] 3 2*3.5 ## [1] 7 10.1^3 ## [1] 1030.301 R vefügt für den Datentypen numeric über viele elementare Grundfunktionen. Hier nur ein paar wenige relevante Beispiele: Operation Beschreibung Beispiel sqrt() Quadratwurzel sqrt(9) abs() Absolutbetrag abs(-12) log(),exp() Logarithmus und Expontentialfunktion exp(3) round() Runden round(2.12) sqrt(5) ## [1] 2.236068 log(3) ## [1] 1.098612 3.1.1 Funktionsaufrufe Funktionen sind ein wichtiger Teil von R und werden syntaktisch durch eine öffnende und eine schließende Klammer gekennzeichnet, nach diesem Schema: funktion(). Gerade haben wir bereits eine Funktion ausgeführt, indem wir sqrt(9) aufgerufen haben. Ausführlich werden Funktionen noch in Kapitel 3 besprochen. Ein paar Grundlagen wollen wir hier aber schon einmal einführen: Funktionensaufrufe erfolgen in der Regel über das Schema Funktionsname(Argument 1, Argument 2, ...) Beispiel: Die Funktion signif(x,digits) rundet eine Zahl x auf digits signifikante Stellen. Argumente haben zumeist einen festen Namen, sodass diesen eindeutig Werte zugewiesen werden können: signif(x = 12.3456, digits = 3) ## [1] 12.3 Alternativ können aufgrund der Position bzw. der Ordnung den Argumenten Werte zugewiesen werden: signif(12.3456, 3) ## [1] 12.3 3.1.2 Objekte, Funktionen und Referenzen “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” (John M. Chambers) 2 Funktionen haben wir gerade kennengelernt, also kennen wir auch schon “Everything that happens”. Objekte haben wir auch schon durchgehend verwendet. Geben wir etwa 3 oder \"password\" in die Konsole ein, wird ein entsprechendes Objekt im Speicher erzeugt. Auf diese Objekte haben wir allerdings anschließend keinen Zugriff mehr. Wenn wir jetzt zum Beispiel erneut die Zeichenkette \"password\" benötigten, müssten wir sie auch erneut eintippen. Wie wir dies ändern können, sodass uns Objekte längerfristig zur Verfügung stehen, wollen wir uns jetzt anschauen. 3.2 Erzeugung von referenzierbaren Objekten Mit dem Operator &lt;- lässt sich ein referenzierbares Objekt erstellen. Das bedeutet, dass das Objekt an einen Namen gebunden wird: x_test &lt;- 3 Das Objekt lässt sich nun über den Namen aus dem Speicher abrufen: x_test ## [1] 3 Wenn wir x_test &lt;- 3 ausführen, passiert formal eigentlich Folgendes: Es wird im Speicher ein Objekt mit Wert 3 erzeugt. Es wird der Name x_test an dieses Objekt gebunden, sodass zu diesen Objekt mit dem Namen x_test referiert werden kann bzw. bei Aufruf von x_test der Wert zurückgegeben wird. Über den Namen, welcher nun an das Objekt gebunden ist, können wir dieses jetzt dauerhaft abrufen (referenzieren). 3.2.1 Anmerkung Namen Für Namen dürfen alle Buchstaben und Zahlen verwendet werden, sowie die beiden Sonderzeichen _ und ., wobei diese nicht am Anfang stehen dürfen. Beispiel: x_1 &lt;- 3 Aber: _x_1 &lt;- 3 ## Error: &lt;text&gt;:1:1: unexpected input ## 1: _ ## ^ Bemerkung: Man sollte sich bei den Buchstaben nur auf a,…,z bzw. A,.., Z beschränken, auch wenn je nach lokalem Setting z.B. auch andere Buchstaben wie ä zulässig sind. 3.2.2 Rechnungen mit Werten von Objekten Das über seinen Namen referenzierbare Objekt steht für alle weiteren Berechnungen und Operationen zur Verfügung: x_test + 2 ## [1] 5 Das Ergebnis dieses Ausdrucks ist ein neues numerisches Objekt. Dieses kann für spätere Zwecke erneut an einen Namen gebunden werden: y_test &lt;- x_test + 2 y_test ## [1] 5 Unser Speicher sieht aktuell so aus: Zwar haben wir für die Berechnung auch eine Zwei im Speicher angelegt, diese ist aber nicht an einen Namen gebunden. Die Drei und die Fünf hingegen schon. Wenn wir nun x_test und y_test aufrufen, bekommen wir jeweils das entsprechende Objekt zurück. 3.2.3 Namen überschreiben ACHTUNG! - Verwendet man denselben Namen noch einmal, geht die ursprüngliche Referenz verloren: y_test &lt;- log(y_test) Wenn wir jetzt das Objekt zum Namen y_test abfragen, sehen Folgendes: y_test ## [1] 1.609438 Das ursprüngliche Objekt zum Namen y_test steht uns nicht mehr zur Verfügung und ist somit unwiederbringlich verloren. Führt man die Codezeile y_test &lt;- log(y_test) jetzt noch einmal aus, so wird y_test wieder an ein anderes Objekt gebunden. Durch dieses Verhalten können wir nie sicher vorhersagen, an welches Objekt y_test momentan gebunden ist. Deswegen sollte man immer neue Namen vergeben und diese nicht doppelt verwenden. 3.2.4 Objekte löschen Wir haben mittlerweile ein paar Objekte im Speicher angelegt und an Namen gebunden. Mit ls() kann man diese abrufen: ls() ## [1] &quot;x_1&quot; &quot;x_test&quot; &quot;y_test&quot; Mit rm() kann man unnötige Objekte über deren Namen entfernen: rm(y_test) Wenn ihr gleich alle angelegte, referenzierbare Objekte aus dem Speicher entfernen wollt: rm(list = ls()) 3.3 Logische Werte und Operationen Die Werte Wahr und Falsch werden in R mit TRUE und FALSE repräsentiert. Es stehen die elementaren Booleschen Operationen zur Verfügung. Operator Bedeutung ! Negation &amp; Und | Oder p &lt;- TRUE !p ## [1] FALSE q &lt;- FALSE (p | q) ## [1] TRUE 3.3.1 Der “logische” Wert NA Neben Wahr und Falsch existiert noch die logische Konstante NA, welche für einen unbestimmten aber bestimmbaren Wert steht (not assigned, not available yet). Dieser Wert wird z. B. universell für alle atomaren Datentypen für die Codierung von Fehlwerten (missings) verwendet. theendoftheworld &lt;- NA 3.3.2 Vergleichs-Operationen Logische Werte spielen in R an verschiedenen Stellen eine große Rolle, da sie z.B. beschreiben, ob bestimmte Vergleiche wahr oder falsch sind. Operator Bedeutung == Gleich? != Ungleich? &gt; / &lt; Größer / Kleiner? &gt;= / &lt;= Größer / Kleiner gleich? alter_tom &lt;- 21 alter_moni &lt;- 24 alter_tom &gt; alter_moni ## [1] FALSE 3.4 Zeichenketten (character strings) Neben Zahlen und logischen Werten, werden wir auch Zeichenketten begegnen bzw. benötigen. Diese können auf zweierlei Art zugewiesen werden: &quot;Tom&quot; ## [1] &quot;Tom&quot; &#39;Moni&#39; ## [1] &quot;Moni&quot; name_bundeskanzler &lt;- &quot;Olaf Scholz&quot; name_bundeskanzler ## [1] &quot;Olaf Scholz&quot; 3.5 Klasse eines Datenobjektes Zur Erinnerung: Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichengfolge “Mexico” NULL,Inf,NaN Leer, Unendlich, keine Zahl Die Klasse bzw. der Datentyp eines Objekts lässt sich mit der Funktion class() ermitteln oder aber spezifisch/logisch prüfen. class(alter_moni) ## [1] &quot;numeric&quot; is.numeric(alter_moni) ## [1] TRUE 3.6 Spezielle Werte Die leere Menge wird in R mit dem Wert NULL repräsentiert und dient ganz verschiedenen Zwecken wie z.B. Initialisierung einer Variablen: z &lt;- NULL z ## NULL Division durch 0 ist “erlaubt” und liefert den speziellen Wert Inf zurück. 100/0 ## [1] Inf In R wird ein nicht bestimmbarer Wert (vgl. unbestimmter aber bestimmbarer Wert ‘NA’) durch NaN (not a number) 0/0 3.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest verstanden haben, warum man verschiedene Datentypen unterscheidet. Du solltest die drei Grundlegenden weisen Informationen zu repräsentieren nennen können und die dazugehörigen Datentypen. Du solltest verstanden haben, wie man Objekte an einen Namen bindet und warum das nützlich sein kann. Du solltest die elementaren Booleschen (logischen) Operationen in R schreiben können. https://de.wikipedia.org/wiki/R_%28Programmiersprache%29↩︎ "],["funktionen.html", "Chapter 4 Funktionen", " Chapter 4 Funktionen "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
=======
[["index.html", "Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Kapitel 1 Einführung 1.1 Was ist R und warum sollte man R lernen? 1.2 Installation", " Handout für R Grundkurs URZ und Academic Lab Universität Leipzig Peter Kannewitz &amp; Peer Schwertfeger Stand: 2022-04-02 Kapitel 1 Einführung Dieses Handout ist Teil des Grundkurses in R am URZ und am Academic Lab der Uni Leipzig. Dieses Dokument ist in ständiger Bearbeitung und kann sich daher regelmäßig Ändern. Besonderem Dank gilt Stephan Poppe für die Unterstützung beim Erstellen der Materialien für diesen Kurs. 1.1 Was ist R und warum sollte man R lernen? R ist eine freie Programmiersprache, die in erster Linie für statistische Analysen konzipiert wurde. Durch ihre große Community (siehe Stack Overflow oder RBlogger) und ihre ständige Weiterentwicklung durch sogenannte Packages, ist der Funktionsumfang von R praktisch unbegrenzt. Neben den klassischen Funktionen statistischer Software (Datenaufbereitung, Analysen, Graphikerstellung) sind z.B. folgende Anwendungen möglich: Erstellen von Präsentationen und Papern (mit RMarkdown) Webscraping Qualitative Textanalyse Auslesen von Datenbanken Automatisierungen uvm. Zum Teil durch die vielfältigen Anwendungsmöglichkeiten hat sich bzw. entwickelt sich R zum Goldstandard in der akademischen Welt und in vielen Bereichen der Wirtschaft1. Wie auch bei Sprachen, lernt man Programmiersprachen nicht (nur) durch Kurse. Eine Aktive Auseinandersetzung mit konkreten Problemen hilft, “fließender” im Umgang mit der Sprache zu werden. Kommt man einmal nicht weiter (wird passieren… versprochen!), hilft es, sich solange mit dem Thema zu beschäftigen, bis eine Lösung gefunden wurde. Warum sollte man das auf sich nehmen? 6 Gründe, R zu lernen: Open Source und plattformübergreifend Praktisch unbegrenzter Funktionsumfang Entwickelt sich zum Standard in akademischer Welt und in der Wirtschaft Publizierfähige Graphiken Integration von Aufbereitung, Analyse und Präsentation Internationale Community (Stack Overflow, RBloggers etc.) 1.2 Installation Zunächst muss unser Computer R “lernen”. Um R zu installieren, gehe auf die entsprechende Cran Website. Wähle dein Betriebssystem aus und folge den Anweisungen auf der Website. Um produktiv zu arbeiten, sollte zusätzlich die open source-Vesion von RStudio installiert werden. Weitere Infos hierzu gibt es hier. https://analyticsindiamag.com/has-python-completely-edged-out-r-in-data-science-field/↩︎ "],["oberfläche.html", "Kapitel 2 Oberfläche 2.1 R GUI 2.2 RStudio 2.3 Prüfe dich selbst", " Kapitel 2 Oberfläche 2.1 R GUI Mit der Installation von R wird gleichzeitig ein Graphical User Interface (GUI) mitinstalliert. Hier können wir bereits R Code eingeben und mit Enter an den Computer übergeben. In der nächsten Zeile wird die Antwort vom Computer an uns zurückgegeben. Figure 2.1: R GUI Diese Oberfläche ist jedoch wenig “komfortabel”. Sie bietet keine zusätzlichen Editoren oder Fenster, um z.B. die gespeicherten Objekte oder Graphiken anzuzeigen. 2.2 RStudio RStudio bietet eine nutzer:innenfreundliche (und freie) Alternative für die Nutzung von R. Hier sind zusätzliche Editoren und Übersichten enthalten. Zu nennen ist beispielsweise: Script-Editor Übersicht über Objekte in globaler Umgebung Übersicht über Packages Einfache Dateienhandhabung durch Projects u.v.m. Das Interface von RStudio besteht aus mehreren Fenstern. Figure 2.2: RStudio Interface 2.2.1 Console Figure 2.3: Console Die R Console dient zur direkten Übergabe von Ausdrücken bzw. Funktionen an R und ist identisch mit der Anzeige in der R GUI. Diese eignet sich für für kleine Tasks bzw. Tests. Das Ergebnis wird direkt unterhalb des Befehls angezeigt. Außerderm werden Ergebnisse aus den Scripten, die keine Graphiken sind, hier angezeigt. Nachdem Code hier eingetippt wurde, wird die Befehlszeile mit der Taste ENTER ausgeführt. 2.2.2 Script Editor In der Console kann euer Code langfristig nicht gespeichert werden. Sogenannte R Scripte ermöglichen euch, euren Code zu speichern und nacheinander auszuführen. Der entsprechende Editor muss zunächst händisch geöffnet werden: File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script Nachdem Code geschrieben wurde, kann der Code mit folgender Tastenkombination ausgeführt werden: strg + ENTER (Win) bzw. command + ENTER (Mac) Hierzu genügt es, wenn sich der Cursor in einer der Zeilen der Befehlssequenz befindet. Sollen mehrere Befehlssequenzen ausgeführt werden, müssen diese vorher markiert werden. Mit # lassen sich Kommentare in das Script schreiben. Zeilen, in denen dieses Zeichen steht, werden von R ignoriert und nicht ausgeführt. 2.2.3 File-Editor und Environment Figure 2.4: File-Editor und Environment-Oberfläche Zusätzlich zu der Console und dem Skript-Editor bietet RStudio weitere Fenster, die die Arbeit mit R vereinfachen sollen. Das Fenster unten rechts (Standardeinstellung, Abb. 2.4a) beinhaltet einen File-Editor (ähnlich zum File Browser (Win) bzw. Finder (Mac)). Hier können Dateien und Verzeichnisstrukturen angesehen und bearbeitet werden (neuer Ordner, Umbenennen von Dateien). Außerdem werden hier Graphiken angezeigt, wenn diese über Code in Scripten oder in der Console erzeugt werden. Des Weiteren gibt es hier eine Übersicht über Packages und das Help Fenster. Oben rechts (Standardeinstellung, Abb. 2.4b) existiert die Global Environment, in dem alle gespeicherten Objekte angezeigt werden. Schließlich kann man hier auf die History und Verbindungen, wie GitHub, zugegriffen werden. 2.3 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: Du solltest die Wesentliche Funktionsweise von R verstanden haben. Du solltest den Aufbau von RStudio kennen. Du solltest wissen, was ein Script ist und wie es geöffnet werden kann. Du solltest wissen, wie Befehlssequenzen in der Console und in einem Script ausgeführt werden. "],["atomare-datentypen.html", "Kapitel 3 Atomare Datentypen 3.1 Arithmetische Grundoperationen und Basisfunktionen 3.2 Erzeugung von Objekten 3.3 Logische Werte und Operationen 3.4 Zeichen (character) 3.5 Klasse eines Datenobjektes 3.6 Spezielle Werte 3.7 Prüfe dich selbst", " Kapitel 3 Atomare Datentypen Datentypen sind die Grundlage einer jeder Programmiersprache und somit essenziell zum Verständnis dieser. Sie dienen dazu, verschiedene Typen unterscheiden. Etwa Zahlen von Buchstaben. Das ist besonders wichtig, da wir mit unterschiedlichen ‘Typen’ unterschiedliche Operationen ausführen, bzw. nicht ausführen, können. Zum Beispiel können wir mit Zahlen rechnen, mit Buchstaben hingegen nicht. Mit logischen Bedingungen können wir wiederum Wahrheitswerte ermitteln, mit Zahlen hingegen nicht. Zu wissen, welche Eigenschaften die verschiedene Datentypen haben und welche Operationen mit diesen möglich sind, hilft dabei vielen potenziellen Fehlern vorzubeugen und so Frustration zu vermeiden. Zunächst einmal wollen wir uns die atomaren Datentypen anschauen. Diese bilden die Grundlage aller folgenden Datentypen. Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichenfolge “Mexico” NA,NULL,NaN Unbestimmt, Leer, Undefiniert Inf Unendlich Die numerischen Datentypen integer und numeric erlauben es uns numerische Informationen zu repräsentieren. Mit dem Datentyp logic können wir logische Informationen repräsentieren. Um symbolische Informationen zu repräsentieren, verwenden wir den Datentyp character. Mit numerischen-, logischen- und symbolischen Informationen ist es bereits möglich eine Vielzahl von Sachverhalten auszudrücken. Was dies sein kann, wollen wir uns im Folgenden anschauen. 3.1 Arithmetische Grundoperationen und Basisfunktionen R beherscht für alle Zahlen die arithmetischen Grundoperationen und eignet sich somit wunderbar als Taschenrechner. Operation Beschreibung Beispiel +,- Addition, Subtraktion 3-1.2 *,/ Multiplikation, Division 4.8/4 ^ Potenz 5^2 Beispiel: 1+2 ## [1] 3 2*3.5 ## [1] 7 10.1^3 ## [1] 1030.301 R vefügt für den Datentypen numeric über viele elementare Grundfunktionen. Hier nur ein paar wenige relevante Beispiele: Operation Beschreibung Beispiel sqrt() Quadratwurzel sqrt(9) abs() Absolutbetrag abs(-12) log(),exp() Logarithmus und Expontentialfunktion exp(3) round() Runden round(2.12) sqrt(5) ## [1] 2.236068 log(3) ## [1] 1.098612 3.1.1 Funktionsaufrufe Funktionen sind ein wichtiger Teil von R und werden syntaktisch durch eine öffnende und eine schließende Klammer gekennzeichnet, nach diesem Schema: funktion(). Gerade haben wir bereits eine Funktion ausgeführt, indem wir sqrt(9) aufgerufen haben. Ausführlich werden Funktionen noch in Kapitel 3 besprochen. Ein paar Grundlagen wollen wir hier aber schon einmal einführen: Funktionensaufrufe erfolgen in der Regel über das Schema Funktionsname(Argument 1, Argument 2, ...) Beispiel: Die Funktion signif(x,digits) rundet eine Zahl x auf digits signifikante Stellen. Argumente haben zumeist einen festen Namen, sodass diesen eindeutig Werte zugewiesen werden können: signif(x = 12.3456, digits = 3) ## [1] 12.3 Alternativ können aufgrund der Position bzw. der Ordnung den Argumenten Werte zugewiesen werden: signif(12.3456, 3) ## [1] 12.3 3.1.2 Was wir bisher getan haben “To understand computations in R, two slogans are helpful: Everything that exists is an object. Everything that happens is a function call.” (John M. Chambers) 2 bis jetzt haben wir uns nur Funktionen angeschaut die Ergebnisse der Funktionen sind alle flüchtig und “existieren” somit nicht, da diese nicht an ein Objekt gebunden sind Geben wir etwa die Zahl 3 oder die Zeichenkette \"password\" in die Konsole ein, bekommen wir dieselben Werte zurück. Diese wurden somit im Speicher angelegt. Allerdings können wir auf die Werte nicht mehr zugreifen. Wenn wir zum Beispiel erneut die Zeichenkette \"password\" benötigten, müssten wir sie erneut eintippen. Auf die bereits im Speicher existierende haben wir keinen Zugriff. Wie wir das ändern können und für uns ‘existierende’ Objekte erzeugen können, wollen wir uns nun anschauen. 3.2 Erzeugung von Objekten Mit dem Operator &lt;- lässt sich ein Objekt erstellen, welche aus einem Namen (x_test) und einem Wert (3) besteht: x_test &lt;- 3 Der Wert dieses Objekts lässt sich über den Namen aus dem Speicher abrufen: x_test ## [1] 3 Wenn wir x_test &lt;- 3 ausführen, passiert formal eigentlich Folgendes: Es wird im Speicher ein Objekt mit Wert 3 erzeugt. Es wird der Name x_test an dieses Objekt gebunden, sodass zu diesen Objekt mit dem Namen x_test referiert werden kann bzw. bei Aufruf von x_test der Wert zurückgegeben wird. Über den Namen unseren neues Objektes können wir nun dauerhaft dessen Wert (3) abrufen. 3.2.1 Anmerkung Namen Für Namen dürfen alle Buchstaben und Zahlen verwendet werden, sowie die beiden Sonderzeichen _ und ., wobei diese nicht am Anfang stehen dürfen. Beispiel: x_1 &lt;- 3 Aber: _x_1 &lt;- 3 ## Error: &lt;text&gt;:1:1: unexpected input ## 1: _ ## ^ Bemerkung: Man sollte sich bei den Buchstaben nur auf a,…,z bzw. A,.., Z beschränken, auch wenn je nach lokalem Setting z.B. auch andere Buchstaben wie ä zulässig sind. 3.2.2 Rechnungen mit Werten von Objekten Befindet sich das Objekt im Speicher, so steht es für alle weiteren Berechnungen und Operationen zur Verfügung: x_test + 2 ## [1] 5 Das Ergebnis bzw. der Wert eines solchen Ausdrucks lässt sich aber auch für spätere Zwecke einem neuen Objekt zuordnen: y_test &lt;- x_test + 2 y_test ## [1] 5 Unser Speicher sieht aktuell so aus: Zwar haben wir für die Berechnung auch eine Zwei im Speicher angelegt, diese ist aber nicht an ein Objekt gebunden. Die Drei und die Fünf hingegen schon. Wenn wir nun x_test und y_test aufrufen, bekommen wir jeweils den entsprechenden Wert zurück. 3.2.3 Objekte überschreiben ACHTUNG! - Verwendet man den selben Objektnamen nocheinmal, geht die ursprüngliche Referenz verloren: y_test &lt;- log(y_test) Wenn wir jetzt den Wert des Objekts y_test abfragen sehen wir folgendes: y_test ## [1] 1.609438 Der ursprüngliche Wert des Objektes namens y_test steht uns nicht mehr zur Verfügung und somit unwiederbringlich verloren. Führt man die Codezeile y_test &lt;- log(y_test) jetzt noch einmal aus, so wird y_test wieder ein anderer Wert zugewiesen. Durch dieses Verhalten können wir nie sicher vorhersagen, welchen Wert y_test momentan hat. Deswegen sollte man immer neue Objektnamen vergeben und diese nicht doppelt verwenden. 3.2.4 Objekte löschen Wir haben mittlerweile eine Menge Objekte im Speicher angelegt. Mit ls() kann man diese abrufen: ls() ## [1] &quot;alter_moni&quot; &quot;alter_tom&quot; &quot;name_bundeskanzler&quot; &quot;p&quot; &quot;q&quot; &quot;theendoftheworld&quot; ## [7] &quot;x_1&quot; &quot;x_test&quot; &quot;y_test&quot; &quot;z&quot; Mit rm() kann man unnötige Objekte entfernen: rm(y_test) Wenn ihr gleich alle angelegten Objekte aus dem Arbeitsspeicher entfernen wollt: rm(list = ls()) 3.3 Logische Werte und Operationen Die Werte Wahr und Falsch werden in R mit TRUE und FALSE repräsentiert. Es stehen die elementaren Boolschen Operationen zur Verfügung. Operator Bedeutung ! Negation &amp; Und | Oder p &lt;- TRUE !p ## [1] FALSE q &lt;- FALSE (p | q) ## [1] TRUE 3.3.1 Der “logische” Wert NA Neben Wahr und Falsch existiert noch die logische Konstante NA, welche für einen unbestimmten aber bestimmbaren Wert steht (not assigned, not available yet). Dieser Wert wird z. B. universell für alle atomaren Datentypen für die Codierung von Fehlwerten (missings) verwendet. theendoftheworld &lt;- NA 3.3.2 Vergleichs-Operationen Logische Werte spielen in R an verschiedenen Stellen eine große Rolle, da sie z.B. beschreiben, ob bestimmte Vergleiche wahr oder falsch sind. Operator Bedeutung == Gleich? != Ungleich? &gt; / &lt; Größer / Kleiner? &gt;= / &lt;= Größer / Kleiner gleich? alter_tom &lt;- 21 alter_moni &lt;- 24 alter_tom &gt; alter_moni ## [1] FALSE 3.4 Zeichen (character) Neben Zahlen und logischen Werten, werden wir auch Zeichenketten begegnen bzw. benötigen. Diese können auf zweierlei Art zugewiesen werden: &quot;Tom&quot; ## [1] &quot;Tom&quot; &#39;Moni&#39; ## [1] &quot;Moni&quot; name_bundeskanzler &lt;- &quot;Olaf Scholz&quot; name_bundeskanzler ## [1] &quot;Olaf Scholz&quot; 3.5 Klasse eines Datenobjektes Zur Erinnerung: Datentyp Beschreibung Beispiel integer ganze Zahlen -2L numeric reelle Zahlen 5.2456 logic logische Werte TRUE character Zeichengfolge “Mexico” NULL,Inf,NaN Leer, Unendlich, keine Zahl Die Klasse bzw. der Datentyp eines Objekts lässt sich mit der Funktion class() ermitteln oder aber spezifisch/logisch prüfen. class(alter_moni) ## [1] &quot;numeric&quot; is.numeric(alter_moni) ## [1] TRUE 3.6 Spezielle Werte Die leere Menge wird in R mit dem Wert NULL repräsentiert und dient ganz verschiedenen Zwecken wie z.B. Initialisierung einer Variablen: z &lt;- NULL z ## NULL Division durch 0 ist “erlaubt” und liefert den speziellen Wert Inf zurück. 100/0 ## [1] Inf In R wird ein nicht bestimmbarer Wert (vgl. unbestimmter aber bestimmbarer Wert ‘NA’) durch NaN (not a number) 0/0 3.7 Prüfe dich selbst Von dieser Sitzung solltest du folgendes mitgenommen haben: du solltest verstanden haben, warum man verschiedene Datentypen unterscheidet du solltest die drei Grundlegenden weisen Informationen zu repräsentieren nennen können und die dazugehörigen Datentypen du solltest verstanden haben wie man ein Objekt anlegt und wozu das nützlich sein könnte du solltest die elementaren Boolschen (logische) Operationen in R schreiben können https://de.wikipedia.org/wiki/R_%28Programmiersprache%29↩︎ "],["funktionen.html", "Kapitel 4 Funktionen", " Kapitel 4 Funktionen "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
>>>>>>> cb540add05f3f2b60c4e9c302b546d0ee77b6674
